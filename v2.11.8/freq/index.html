<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Frequency-domain estimation · ControlSystemIdentification Documentation</title><meta name="title" content="Frequency-domain estimation · ControlSystemIdentification Documentation"/><meta property="og:title" content="Frequency-domain estimation · ControlSystemIdentification Documentation"/><meta property="twitter:title" content="Frequency-domain estimation · ControlSystemIdentification Documentation"/><meta name="description" content="Documentation for ControlSystemIdentification Documentation."/><meta property="og:description" content="Documentation for ControlSystemIdentification Documentation."/><meta property="twitter:description" content="Documentation for ControlSystemIdentification Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ControlSystemIdentification Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iddata/">Identification data</a></li><li><a class="tocitem" href="../ss/">State-space estimation</a></li><li><a class="tocitem" href="../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../impulse/">Impulse-response estimation</a></li><li class="is-active"><a class="tocitem" href>Frequency-domain estimation</a><ul class="internal"><li><a class="tocitem" href="#Nonparametric-estimation"><span>Nonparametric estimation</span></a></li><li><a class="tocitem" href="#Parametric-estimation"><span>Parametric estimation</span></a></li><li><a class="tocitem" href="#Model-based-spectral-estimation"><span>Model-based spectral estimation</span></a></li></ul></li><li><a class="tocitem" href="../validation/">Validation</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear identification</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/temp/">Temperature control</a></li><li><a class="tocitem" href="../examples/closed_loop_id/">Identification in closed loop</a></li><li><a class="tocitem" href="../examples/unstable_systems/">Identification of unstable systems</a></li><li><a class="tocitem" href="../examples/delayest/">Delay estimation</a></li><li><a class="tocitem" href="../examples/ballandbeam/">Ball and beam</a></li><li><a class="tocitem" href="../examples/flexible_robot/">Flexible robot arm</a></li><li><a class="tocitem" href="../examples/glass_furnace/">Glass furnace</a></li><li><a class="tocitem" href="../examples/evaporator/">Evaporator</a></li><li><a class="tocitem" href="../examples/hair_dryer/">Hair dryer</a></li><li><a class="tocitem" href="../examples/varx/">VARX model</a></li><li><a class="tocitem" href="../examples/hammerstein_wiener/">Nonlinear belt drive</a></li><li><a class="tocitem" href="../examples/modelingtoolkit/">Fit parameters of ModelingToolkit model</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Frequency-domain estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Frequency-domain estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/freq.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Transfer-function-estimation-using-spectral-techniques"><a class="docs-heading-anchor" href="#Transfer-function-estimation-using-spectral-techniques">Transfer-function estimation using spectral techniques</a><a id="Transfer-function-estimation-using-spectral-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Transfer-function-estimation-using-spectral-techniques" title="Permalink"></a></h1><p>Frequency-domain estimation refers to estimation of linear systems using frequency-domain data. We distinguish between nonparametric and parametric models, where parametric models have a fixed number of parameters (such as transfer functions with polynomials or statespace models), whereas nonparametric models are typically given as vectors of frequency-response values over a grid of frequencies, i.e., the number of parameters is not fixed and grows with the number of data points.</p><h2 id="Nonparametric-estimation"><a class="docs-heading-anchor" href="#Nonparametric-estimation">Nonparametric estimation</a><a id="Nonparametric-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Nonparametric-estimation" title="Permalink"></a></h2><p>Non-parametric estimation refers to the estimation of a model without a fixed number of parameters. Instead, the number of estimated parameters typically grows with the size of the data. This form of estimation can be useful to gain an initial understanding of the system, before selecting model orders etc. for a more standard parametric model. We provide non-parametric estimation of transfer functions through spectral estimation. To illustrate, we once again simulate some data:</p><pre><code class="language-julia hljs">using ControlSystemIdentification, ControlSystemsBase, Plots
T          = 100000
h          = 1
sim(sys,u) = lsim(sys, u, 1:T)[1][:]
σy         = 0.5
sys        = tf(1,[1,2*0.1,0.1])
ωn         = sqrt(0.3)
sysn       = tf(σy*ωn,[1,2*0.1*ωn,ωn^2])

u  = randn(1, T)
y  = sim(sys, u)
yn = y + sim(sysn, randn(size(u))) # Add noise filtered through sysn
d  = iddata(y,u,h)
dn = iddata(yn,u,h)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">InputOutput data of length 100000, 1 outputs, 1 inputs, Ts = 1</code></pre><p>We can now estimate the coherence function to get a feel for whether or nor our data seems to be generated by a linear system:</p><pre><code class="language-julia hljs">k = coherence(d)  # Should be close to 1 if the system is linear and noise free
k = coherence(dn) # Slightly lower values are obtained if the system is subject to measurement noise</code></pre><p>We can also estimate a transfer function using spectral techniques, the main entry point to this is the function <a href="#ControlSystemIdentification.tfest"><code>tfest</code></a>, which returns a transfer-function estimate and an estimate of the power-spectral density of the noise (note, the unit of the PSD is squared compared to a transfer function, hence the <code>√N</code> when plotting it in the code below):</p><pre><code class="language-julia hljs">G,N = tfest(dn)
bodeplot([sys,sysn], exp10.(range(-3, stop=log10(pi), length=200)), layout=(1,3), plotphase=false, subplot=[1,2,2], ylims=(0.1,300), linecolor=:blue)

coherenceplot!(dn, subplot=3)
plot!(G, subplot=1, lab=&quot;G Est&quot;, alpha=0.3, title=&quot;Process model&quot;)
plot!(√N, subplot=2, lab=&quot;N Est&quot;, alpha=0.3, title=&quot;Noise model&quot;)</code></pre><img src="0d8ffa73.png" alt="Example block output"/><p>The left figure displays the Bode magnitude of the true system, together with the estimate (noisy), and the middle figure illustrates the estimated noise model. The right figure displays the coherence function (<a href="../api/#ControlSystemIdentification.coherenceplot"><code>coherenceplot</code></a>), which is close to 1 everywhere except for at the resonance peak of the noise <code>log10(sqrt(0.3)) = -0.26</code>.</p><p>See the <a href="https://github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for more details.</p><h2 id="Parametric-estimation"><a class="docs-heading-anchor" href="#Parametric-estimation">Parametric estimation</a><a id="Parametric-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-estimation" title="Permalink"></a></h2><h3 id="Transfer-functions"><a class="docs-heading-anchor" href="#Transfer-functions">Transfer functions</a><a id="Transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Transfer-functions" title="Permalink"></a></h3><p>To estimate a parametric, rational transfer function from frequency-domain data, call <a href="#ControlSystemIdentification.tfest"><code>tfest</code></a> with an <a href="../api/#ControlSystemIdentification.FRD"><code>FRD</code></a> object and an initial guess for the system model. This initial guess determines the number of coefficients in the numerator and denominator of the estimated model.</p><pre><code class="language-julia hljs">G0 = tf(1.0, [1,1,1]) # Initial guess
G = tfest(d::FRD, G0)</code></pre><p>Internally, Optim is using a gradient-based optimizer to find the optimal fit of the bode curve of the system. The default optimizer <code>BFGS</code> can be changed, see the docstring <code>?tfest</code>.</p><p>For a comparison between estimation in the time and frequency domains, see <a href="https://nbviewer.jupyter.org/github/JuliaControl/ControlExamples.jl/blob/master/identification_time_vs_freq.ipynb">this notebook</a>.</p><p>If the above problem is hard to solve, you may parametrize the model using, e.g., a Laguerre basis expansion, example:</p><pre><code class="language-julia hljs">basis = laguerre_oo(1, 50) # Use 50 basis functions, the final model order may be reduced with baltrunc
Gest,p = tfest(d::FRD, basis)</code></pre><div class="admonition is-info" id="Note-f4a45dee14344f0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f4a45dee14344f0" title="Permalink"></a></header><div class="admonition-body"><p>Most methods for frequency-domain estimation of transfer functions handle SISO or SIMO systems only. For estimation of MIMO systems, consider using state-space based methods and convert the result to a transfer function using <code>tf</code> after estimation if required. </p></div></div><h3 id="Statespace"><a class="docs-heading-anchor" href="#Statespace">Statespace</a><a id="Statespace-1"></a><a class="docs-heading-anchor-permalink" href="#Statespace" title="Permalink"></a></h3><p>The function <a href="../ss/#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> handles frequency-domain data (as well as time-domain data). If an <a href="../api/#ControlSystemIdentification.InputOutputFreqData"><code>InputOutputFreqData</code></a> is passed (may be created with function <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a>), a frequency-domain method is automatically used. Further, a frequency-response object, <a href="../api/#ControlSystemIdentification.FRD"><code>FRD</code></a>, may also be passed, in which case it is transformed to an <code>InputOutputFreqData</code> automatically. If the frequency-response data stems from a frequency-response analysis, you may need to perform a bilinear transform on the frequency axis of the data object to convert the continuous-time frequency axis to discrete time, example:</p><pre><code class="language-julia hljs">Ts    = 0.01 # Sample time
frd_d = c2d(frd_c::FRD, Ts) # Perform a bilinear transformation to discrete-time frequency vector
Ph, _ = subspaceid(frd_d, Ts, nx)</code></pre><p>This can be done automatically by passing <code>bilinear_transform = true</code> to <a href="../ss/#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a>.</p><p>The following example generates simulated frequency-response data <code>frd</code> from a random system, this data could in practice have come from a frequency-response analysis. We then use the data to fit a model using subspace-based identification in the frequency domain using <a href="../ss/#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a>.</p><pre><code class="language-julia hljs">using ControlSystemIdentification, ControlSystemsBase, Plots
ny,nu,nx = 2,3,5                        # number of outputs, inputs and states
Ts = 1                                  # Sample time
G = ssrand(ny,nu,nx; Ts, proper=true)   # Generate a random system

N = 200             # Number of frequency points
w = freqvec(Ts, N)
frd = FRD(w, G)     # Build a frequency-response data object (this should in practice come from an experiment)

Gh, x0 = subspaceid(frd, G.Ts, nx; zeroD=true) # Fit frequency response
sigmaplot([G, Gh], w[2:end], lab=[&quot;True system&quot; &quot;Estimated model&quot;])</code></pre><img src="b2f8017f.svg" alt="Example block output"/><h2 id="Model-based-spectral-estimation"><a class="docs-heading-anchor" href="#Model-based-spectral-estimation">Model-based spectral estimation</a><a id="Model-based-spectral-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-based-spectral-estimation" title="Permalink"></a></h2><p>The model estimation procedures can be used to estimate spectrograms. This package extends some methods from DSP.jl to accept a estimation function as the second argument. To create a suitable such function, we provide the function <a href="#ControlSystemIdentification.model_spectrum"><code>model_spectrum</code></a>. Usage is illustrated below.</p><pre><code class="language-julia hljs">using ControlSystemIdentification, DSP
T  = 1000
fs = 1
s = sin.((1:1/fs:T) .* 2pi/10) + 0.5randn(T)
S1 = spectrogram(s,window=hanning, fs=fs)            # Standard spectrogram
estimator = model_spectrum(ar,1/fs,6)
S2 = spectrogram(s,estimator,window=rect, fs=fs)     # Model-based spectrogram
plot(plot(S1,title=&quot;Standard Spectrogram&quot;),plot(S2,title=&quot;AR Spectrogram&quot;)) # Requires the package LPVSpectral.jl</code></pre><p><img src="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/figs/ar_spectrogram.svg?raw=true" alt="window"/></p><ul><li><a href="../api/#ControlSystemIdentification.FRD"><code>ControlSystemIdentification.FRD</code></a></li><li><a href="../api/#ControlSystemIdentification.FRD-Tuple{Any, LTISystem}"><code>ControlSystemIdentification.FRD</code></a></li><li><a href="../api/#ControlSystemIdentification.Hz"><code>ControlSystemIdentification.Hz</code></a></li><li><a href="../api/#ControlSystemIdentification.InputOutputData"><code>ControlSystemIdentification.InputOutputData</code></a></li><li><a href="../api/#ControlSystemIdentification.InputOutputFreqData"><code>ControlSystemIdentification.InputOutputFreqData</code></a></li><li><a href="../api/#ControlSystemIdentification.N4SIDStateSpace"><code>ControlSystemIdentification.N4SIDStateSpace</code></a></li><li><a href="../api/#ControlSystemIdentification.PredictionStateSpace"><code>ControlSystemIdentification.PredictionStateSpace</code></a></li><li><a href="../api/#ControlSystemIdentification.rad"><code>ControlSystemIdentification.rad</code></a></li><li><a href="../validation/#ControlSystemIdentification.aic"><code>ControlSystemIdentification.aic</code></a></li><li><a href="../api/#ControlSystemIdentification.apply_fun"><code>ControlSystemIdentification.apply_fun</code></a></li><li><a href="../api/#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.ar</code></a></li><li><a href="../tf/#ControlSystemIdentification.ar"><code>ControlSystemIdentification.ar</code></a></li><li><a href="../tf/#ControlSystemIdentification.arma"><code>ControlSystemIdentification.arma</code></a></li><li><a href="../api/#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma</code></a></li><li><a href="../api/#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma_ssa</code></a></li><li><a href="../api/#ControlSystemIdentification.armax"><code>ControlSystemIdentification.armax</code></a></li><li><a href="../tf/#ControlSystemIdentification.arx"><code>ControlSystemIdentification.arx</code></a></li><li><a href="../api/#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arx</code></a></li><li><a href="../tf/#ControlSystemIdentification.arxar"><code>ControlSystemIdentification.arxar</code></a></li><li><a href="../api/#ControlSystemIdentification.arxar-Tuple{InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}"><code>ControlSystemIdentification.arxar</code></a></li><li><a href="../api/#ControlSystemIdentification.autocorplot"><code>ControlSystemIdentification.autocorplot</code></a></li><li><a href="../api/#ControlSystemIdentification.basis_responses-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.basis_responses</code></a></li><li><a href="#ControlSystemIdentification.coherence"><code>ControlSystemIdentification.coherence</code></a></li><li><a href="../api/#ControlSystemIdentification.coherence-Tuple{ControlSystemIdentification.AbstractIdData}"><code>ControlSystemIdentification.coherence</code></a></li><li><a href="../api/#ControlSystemIdentification.coherenceplot"><code>ControlSystemIdentification.coherenceplot</code></a></li><li><a href="../api/#ControlSystemIdentification.crosscorplot"><code>ControlSystemIdentification.crosscorplot</code></a></li><li><a href="../api/#ControlSystemIdentification.detrend-Tuple{AbstractVector}"><code>ControlSystemIdentification.detrend</code></a></li><li><a href="../api/#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="../ss/#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="../api/#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="../api/#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>ControlSystemIdentification.estimate_residuals</code></a></li><li><a href="../api/#ControlSystemIdentification.estimate_x0"><code>ControlSystemIdentification.estimate_x0</code></a></li><li><a href="../api/#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemIdentification.filter_bank</code></a></li><li><a href="../api/#ControlSystemIdentification.find_na"><code>ControlSystemIdentification.find_na</code></a></li><li><a href="../api/#ControlSystemIdentification.find_nanb"><code>ControlSystemIdentification.find_nanb</code></a></li><li><a href="../validation/#ControlSystemIdentification.fpe"><code>ControlSystemIdentification.fpe</code></a></li><li><a href="../api/#ControlSystemIdentification.freqvec-Tuple{Any, AbstractVector}"><code>ControlSystemIdentification.freqvec</code></a></li><li><a href="../api/#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector, AbstractVecOrMat, Any, Any}"><code>ControlSystemIdentification.getARXregressor</code></a></li><li><a href="../tf/#ControlSystemIdentification.getARXregressor"><code>ControlSystemIdentification.getARXregressor</code></a></li><li><a href="../api/#ControlSystemIdentification.getARregressor-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.getARregressor</code></a></li><li><a href="../tf/#ControlSystemIdentification.getARregressor"><code>ControlSystemIdentification.getARregressor</code></a></li><li><a href="../api/#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector}"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="../api/#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="../api/#ControlSystemIdentification.iddata-Tuple{ControlSystemsBase.SimResult}"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="../iddata/#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="../api/#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.impulseest</code></a></li><li><a href="../api/#ControlSystemIdentification.impulseestplot"><code>ControlSystemIdentification.impulseestplot</code></a></li><li><a href="../api/#ControlSystemIdentification.kautz-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.kautz</code></a></li><li><a href="../api/#ControlSystemIdentification.laguerre-Tuple{Any, Any}"><code>ControlSystemIdentification.laguerre</code></a></li><li><a href="../api/#ControlSystemIdentification.laguerre_id-Tuple{Any, Any, Any}"><code>ControlSystemIdentification.laguerre_id</code></a></li><li><a href="#ControlSystemIdentification.laguerre_oo"><code>ControlSystemIdentification.laguerre_oo</code></a></li><li><a href="../api/#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}"><code>ControlSystemIdentification.laguerre_oo</code></a></li><li><a href="../api/#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous}}"><code>ControlSystemIdentification.minimum_phase</code></a></li><li><a href="../api/#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any}}"><code>ControlSystemIdentification.model_spectrum</code></a></li><li><a href="#ControlSystemIdentification.model_spectrum"><code>ControlSystemIdentification.model_spectrum</code></a></li><li><a href="../api/#ControlSystemIdentification.modelfit-Tuple{Any, Any}"><code>ControlSystemIdentification.modelfit</code></a></li><li><a href="../validation/#ControlSystemIdentification.mse"><code>ControlSystemIdentification.mse</code></a></li><li><a href="../ss/#ControlSystemIdentification.n4sid"><code>ControlSystemIdentification.n4sid</code></a></li><li><a href="../api/#ControlSystemIdentification.n4sid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.n4sid</code></a></li><li><a href="../ss/#ControlSystemIdentification.newpem"><code>ControlSystemIdentification.newpem</code></a></li><li><a href="../api/#ControlSystemIdentification.newpem-Union{Tuple{RE}, Tuple{F}, Tuple{Any, Any}} where {F, RE}"><code>ControlSystemIdentification.newpem</code></a></li><li><a href="../ss/#ControlSystemIdentification.noise_model"><code>ControlSystemIdentification.noise_model</code></a></li><li><a href="../api/#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}"><code>ControlSystemIdentification.noise_model</code></a></li><li><a href="../nonlinear/#ControlSystemIdentification.nonlinear_pem"><code>ControlSystemIdentification.nonlinear_pem</code></a></li><li><a href="../ss/#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a></li><li><a href="../api/#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a></li><li><a href="../api/#ControlSystemIdentification.pem-Tuple{Any}"><code>ControlSystemIdentification.pem</code></a></li><li><a href="../api/#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}"><code>ControlSystemIdentification.plr</code></a></li><li><a href="../tf/#ControlSystemIdentification.plr"><code>ControlSystemIdentification.plr</code></a></li><li><a href="../ss/#ControlSystemIdentification.prediction_error"><code>ControlSystemIdentification.prediction_error</code></a></li><li><a href="../api/#ControlSystemIdentification.prediction_error-Tuple{AbstractStateSpace, ControlSystemIdentification.AbstractIdData, Vararg{Any}}"><code>ControlSystemIdentification.prediction_error</code></a></li><li><a href="../api/#ControlSystemIdentification.prediction_error_filter-Tuple{AbstractStateSpace, Vararg{Any}}"><code>ControlSystemIdentification.prediction_error_filter</code></a></li><li><a href="../ss/#ControlSystemIdentification.prediction_error_filter"><code>ControlSystemIdentification.prediction_error_filter</code></a></li><li><a href="../iddata/#ControlSystemIdentification.predictiondata"><code>ControlSystemIdentification.predictiondata</code></a></li><li><a href="../api/#ControlSystemIdentification.predictiondata-Tuple{ControlSystemIdentification.AbstractIdData}"><code>ControlSystemIdentification.predictiondata</code></a></li><li><a href="../api/#ControlSystemIdentification.predplot"><code>ControlSystemIdentification.predplot</code></a></li><li><a href="../api/#ControlSystemIdentification.prefilter-Tuple{Any, InputOutputData}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="../api/#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="../api/#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="../api/#ControlSystemIdentification.ramp_in-Tuple{InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_in</code></a></li><li><a href="../api/#ControlSystemIdentification.ramp_out-Tuple{InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_out</code></a></li><li><a href="../api/#ControlSystemIdentification.residualplot"><code>ControlSystemIdentification.residualplot</code></a></li><li><a href="../validation/#ControlSystemIdentification.rms"><code>ControlSystemIdentification.rms</code></a></li><li><a href="../api/#ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemIdentification.schur_stab</code></a></li><li><a href="../api/#ControlSystemIdentification.simplot"><code>ControlSystemIdentification.simplot</code></a></li><li><a href="../api/#ControlSystemIdentification.specplot"><code>ControlSystemIdentification.specplot</code></a></li><li><a href="../validation/#ControlSystemIdentification.sse"><code>ControlSystemIdentification.sse</code></a></li><li><a href="../ss/#ControlSystemIdentification.structured_pem"><code>ControlSystemIdentification.structured_pem</code></a></li><li><a href="../api/#ControlSystemIdentification.structured_pem-Union{Tuple{RE}, Tuple{F}, Tuple{Any, Any}} where {F, RE}"><code>ControlSystemIdentification.structured_pem</code></a></li><li><a href="../ss/#ControlSystemIdentification.subspaceid"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="../api/#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputFreqData, Real}, Tuple{InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="../api/#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any}}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="../api/#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="../api/#ControlSystemIdentification.sum_basis-Tuple{AbstractVector, AbstractVector}"><code>ControlSystemIdentification.sum_basis</code></a></li><li><a href="../api/#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="../api/#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="../api/#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="../api/#ControlSystemIdentification.welchplot"><code>ControlSystemIdentification.welchplot</code></a></li><li><a href="../api/#ControlSystemIdentification.wtls_estimator"><code>ControlSystemIdentification.wtls_estimator</code></a></li><li><a href="../api/#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a></li><li><a href="../ss/#ControlSystemsBase.observer_controller"><code>ControlSystemsBase.observer_controller</code></a></li><li><a href="../ss/#ControlSystemsBase.observer_predictor"><code>ControlSystemsBase.observer_predictor</code></a></li><li><a href="../api/#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, Real}"><code>DSP.Filters.resample</code></a></li><li><a href="../api/#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, Real}"><code>DSP.Filters.resample</code></a></li><li><a href="../api/#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>DSP.Filters.resample</code></a></li><li><a href="../api/#DelimitedFiles.writedlm"><code>DelimitedFiles.writedlm</code></a></li><li><a href="../api/#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="../validation/#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="../api/#StatsAPI.predict-Tuple{TransferFunction, InputOutputData}"><code>StatsAPI.predict</code></a></li><li><a href="../validation/#StatsAPI.predict"><code>StatsAPI.predict</code></a></li><li><a href="../api/#StatsAPI.predict-Tuple{TransferFunction, Any}"><code>StatsAPI.predict</code></a></li><li><a href="../api/#StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any}}"><code>StatsAPI.predict</code></a></li><li><a href="../api/#StatsAPI.residuals-Tuple{TransferFunction, InputOutputData}"><code>StatsAPI.residuals</code></a></li></ul><ul><li><a href="../api/#ControlSystemIdentification.welchplot"><code>ControlSystemIdentification.welchplot</code></a></li><li><a href="../api/#ControlSystemIdentification.specplot"><code>ControlSystemIdentification.specplot</code></a></li><li><a href="../api/#ControlSystemIdentification.coherenceplot"><code>ControlSystemIdentification.coherenceplot</code></a></li><li><a href="../api/#ControlSystemIdentification.autocorplot"><code>ControlSystemIdentification.autocorplot</code></a></li><li><a href="../api/#ControlSystemIdentification.crosscorplot"><code>ControlSystemIdentification.crosscorplot</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemIdentification.tfest" href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H, N = tfest(data, σ = 0.05, method = :corr)</code></pre><p>Estimate a transfer function model using the Correlogram approach (default) using the signal model <span>$y = H(iω)u + n$</span>.</p><p>Both <code>H</code> and <code>N</code> are of type <code>FRD</code> (frequency-response data).</p><ul><li><code>σ</code> determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger <code>σ</code> implies less smoothing.</li><li><code>H</code> = Syu/Suu             Process transfer function</li><li><code>N</code> = Sy - |Syu|²/Suu     Estimated Noise PSD (also an estimate of the variance of <span>$H$</span>). Note that a PSD is related to the &quot;noise model&quot; <span>$N_m$</span> used in the system identification literature as <span>$N_{psd} = N_m^* N_m$</span>. The magnitude curve of the noise model can be visualized by plotting <code>√(N)</code>.</li><li><code>method</code>: <code>:welch</code> or <code>:corr</code>. <code>:welch</code> uses the Welch method to estimate the power spectral density, while <code>:corr</code> (default) uses the Correlogram approach. If <code>method = :welch</code>, the additional keyword arguments <code>n</code>, <code>noverlap</code> and <code>window</code> determine the number of samples per segment (default 10% of data), the number of samples to overlap between segments (default 50%), and the window function to use (default <code>hamming</code>), respectively.</li></ul><p><strong>Extended help</strong></p><p>This estimation method is unbiased if the input <span>$u$</span> is uncorrelated with the noise <span>$n$</span>, but is otherwise biased (e.g., for identification in closed loop).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/b30bfbe4544836eae169695e939047af405d6757/src/frd.jl#L197-L211">source</a></section><section><div><pre><code class="language-julia hljs">tfest(
    data::FRD,
    p0,
    link = log ∘ abs;
    freq_weight = sqrt(data.w[1]*data.w[end]),
    refine = true,
    opt = BFGS(),
    opts = Optim.Options(
        store_trace       = true,
        show_trace        = true,
        show_every        = 1,
        iterations        = 100,
        allow_f_increases = false,
        time_limit        = 100,
        x_tol             = 0,
        f_tol             = 0,
        g_tol             = 1e-8,
        f_calls_limit     = 0,
        g_calls_limit     = 0,
    ),
)</code></pre><p>Fit a parametric transfer function to frequency-domain data.</p><p>The initial pahse of the optimization solves</p><p class="math-container">\[\operatorname{minimize}_{B,A}{|| B/l - A||}\]</p><p>and the second stage (if refine=true) solves </p><p class="math-container">\[\operatorname{minimize}_{B,A}{|| \text{link}\left(\dfrac{B}{A}\right) - \text{link}\left(l\right)||}\]</p><p>(<code>abs2(link(B/A) - link(l))</code>)</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: An <code>FRD</code> onbject with frequency domain data.</li><li><code>p0</code>: Initial parameter guess. Can be a <code>NamedTuple</code> or <code>ComponentVector</code> with fields <code>b,a</code> specifying numerator and denominator as they appear in the call to <code>tf</code>, i.e., <code>(b = [1.0], a = [1.0,1.0,1.0])</code>. Can also be an instace of <code>TransferFunction</code>.</li><li><code>link</code>: By default, phase information is discarded in the fitting. To include phase, change to <code>link = log</code>.</li><li><code>freq_weight</code>: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.</li><li><code>refine</code>: Indicate whether or not a second optimization stage is performed to refine the results of the first.</li><li><code>opt</code>: The Optim optimizer to use.</li><li><code>opts</code>: <code>Optim.Options</code> controlling the solver options.</li></ul><p>See also <a href="../api/#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous}}"><code>minimum_phase</code></a> to transform a possibly non-minimum phase system to minimum phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/b30bfbe4544836eae169695e939047af405d6757/src/arx.jl#L645-L690">source</a></section><section><div><pre><code class="language-julia hljs">tfest(data::FRD, basis::AbstractStateSpace; 
    freq_weight = 1 ./ (data.w .+ data.w[2]),
    opt = BFGS(),
    metric::M = abs2,
    opts = Optim.Options(
        store_trace       = true,
        show_trace        = true,
        show_every        = 50,
        iterations        = 1000000,
        allow_f_increases = false,
        time_limit        = 100,
        x_tol             = 1e-5,
        f_tol             = 0,
        g_tol             = 1e-8,
        f_calls_limit     = 0,
        g_calls_limit     = 0,
)</code></pre><p>Fit a parametric transfer function to frequency-domain data using a pre-specified basis.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: An <code>FRD</code> onbject with frequency domain data.</li></ul><p>function kautz(a::AbstractVector)</p><ul><li><code>basis</code>: A basis for the estimation. See, e.g., <code>laguerre, laguerre_oo, kautz</code></li><li><code>freq_weight</code>: A vector of weights per frequency. The default is approximately <code>1/f</code>. </li><li><code>opt</code>: The Optim optimizer to use.</li><li><code>opts</code>: <code>Optim.Options</code> controlling the solver options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/b30bfbe4544836eae169695e939047af405d6757/src/arx.jl#L759-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemIdentification.coherence" href="#ControlSystemIdentification.coherence"><code>ControlSystemIdentification.coherence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">κ² = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming, method=:welch)</code></pre><p>Calculates the magnitude-squared coherence Function. κ² close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ² &lt;&lt; 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy.</p><ul><li>κ: Squared coherence function in the form of an <a href="../api/#ControlSystemIdentification.FRD"><code>FRD</code></a>.</li><li><code>method</code>: <code>:welch</code> or <code>:corr</code>. <code>:welch</code> uses the Welch method to estimate the power spectral density, while <code>:corr</code> uses the Correlogram approach . For <code>method = :corr</code>, the additional keyword argument <code>σ</code> determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger <code>σ</code> implies less smoothing.</li></ul><p>See also <a href="../api/#ControlSystemIdentification.coherenceplot"><code>coherenceplot</code></a></p><p><strong>Extended help:</strong></p><p>For the signal model <span>$y = Gu + v$</span>, <span>$κ²$</span> is defined as </p><p class="math-container">\[κ(ω)^2 = \dfrac{S_{uy}}{S_{uu} S_{yy}} = \dfrac{|G(iω)|^2S_{uu}^2}{S_{uu} (|G(iω)|^2S_{uu}^2 + S_{vv})} = \dfrac{1}{1 + \dfrac{S_{vv}}{S_{uu}|G(iω)|^2}}\]</p><p>from which it is obvious that <span>$0 ≤ κ² ≤ 1$</span> and that κ² is close to 1 if the noise energy <span>$S_{vv}$</span> is small compared to the output energy due to the input <span>$S_{uu}|G(iω)|^2$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/b30bfbe4544836eae169695e939047af405d6757/src/frd.jl#L244-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemIdentification.laguerre_oo" href="#ControlSystemIdentification.laguerre_oo"><code>ControlSystemIdentification.laguerre_oo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laguerre_oo(a::Number, Nq)</code></pre><p>Construct an output orthogonalized Laguerre basis of length <code>Nq</code> with poles at <code>-a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/b30bfbe4544836eae169695e939047af405d6757/src/basis_functions.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemIdentification.model_spectrum" href="#ControlSystemIdentification.model_spectrum"><code>ControlSystemIdentification.model_spectrum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">model_spectrum(f, h, args...; kwargs...)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>f</code>: the model-estimation function, e.g., <code>ar,arma</code></li><li><code>h</code>: The sample time</li><li><code>args</code>: arguments to <code>f</code></li><li><code>kwargs</code>: keyword arguments to <code>f</code></li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using ControlSystemIdentification, DSP
T = 1000
s = sin.((1:T) .* 2pi/10)
S1 = spectrogram(s,window=hanning)
estimator = model_spectrum(ar,1,2)
S2 = spectrogram(s,estimator,window=rect)
plot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/b30bfbe4544836eae169695e939047af405d6757/src/spectrogram.jl#L93-L112">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../impulse/">« Impulse-response estimation</a><a class="docs-footer-nextpage" href="../validation/">Validation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Tuesday 17 June 2025 06:30">Tuesday 17 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
