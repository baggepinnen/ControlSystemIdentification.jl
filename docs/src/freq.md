# Transfer-function estimation using spectral techniques

Frequency-domain estimation refers to estimation of linear systems using frequency-domain data. We distinguish between nonparametric and parametric models, where parametric models have a fixed number of parameters (such as transfer functions with polynomials or statespace models), whereas nonparametric models are typically given as vectors of frequency-response values over a grid of frequencies, i.e., the number of parameters is not fixed and grows with the number of data points.

## Nonparametric estimation
Non-parametric estimation is provided through spectral estimation. To illustrate, we once again simulate some data:
```@example npfreq
using ControlSystemIdentification, ControlSystemsBase, Plots
T          = 100000
h          = 1
sim(sys,u) = lsim(sys, u, 1:T)[1][:]
σy         = 0.5
sys        = tf(1,[1,2*0.1,0.1])
ωn         = sqrt(0.3)
sysn       = tf(σy*ωn,[1,2*0.1*ωn,ωn^2])

u  = randn(1, T)
y  = sim(sys, u)
yn = y + sim(sysn, randn(size(u))) # Add noise filtered through sysn
d  = iddata(y,u,h)
dn = iddata(yn,u,h)
```
We can now estimate the coherence function to get a feel for whether or nor our data seems to be generated by a linear system:
```julia
k = coherence(d)  # Should be close to 1 if the system is linear and noise free
k = coherence(dn) # Slightly lower values are obtained if the system is subject to measurement noise
```
We can also estimate a transfer function using spectral techniques, the main entry point to this is the function [`tfest`](@ref), which returns a transfer-function estimate and an estimate of the power-spectral density of the noise (note, the unit of the PSD is squared compared to a transfer function, hence the `√N` when plotting it in the code below):
```@example npfreq
G,N = tfest(dn)
bodeplot([sys,sysn], exp10.(range(-3, stop=log10(pi), length=200)), layout=(1,3), plotphase=false, subplot=[1,2,2], ylims=(0.1,300), linecolor=:blue)

coherenceplot!(dn, subplot=3)
plot!(G, subplot=1, lab="G Est", alpha=0.3, title="Process model")
plot!(√N, subplot=2, lab="N Est", alpha=0.3, title="Noise model")
```
![window](https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/figs/bodecoher.png?raw=true)

The left figure displays the Bode magnitude of the true system, together with the estimate (noisy), and the middle figure illustrates the estimated noise model. The right figure displays the coherence function ([`coherenceplot`](@ref)), which is close to 1 everywhere except for at the resonance peak of the noise `log10(sqrt(0.3)) = -0.26`.

See the [example notebooks](
https://github.com/JuliaControl/ControlExamples.jl?files=1) for more details.

## Parametric estimation
### Transfer functions
To estimate a parametric, rational transfer function from frequency-domain data, call [`tfest`](@ref) with an [`FRD`](@ref) object and an initial guess for the system model. This initial guess determines the number of coefficients in the numerator and denominator of the estimated model.
```julia
G0 = tf(1.0, [1,1,1]) # Initial guess
G = tfest(d::FRD, G0)
```
Internally, Optim is using a gradient-based optimizer to find the optimal fit of the bode curve of the system. The default optimizer `BFGS` can be changed, see the docstring `?tfest`.

For a comparison between estimation in the time and frequency domains, see [this notebook](https://nbviewer.jupyter.org/github/JuliaControl/ControlExamples.jl/blob/master/identification_time_vs_freq.ipynb).

If the above problem is hard to solve, you may parametrize the model using, e.g., a Laguerre basis expansion, example:
```julia
basis = laguerre_oo(1, 50) # Use 50 basis functions, the final model order may be reduced with baltrunc
Gest,p = tfest(d::FRD, basis)
```

!!! note
    Most methods for frequency-domain estimation of transfer functions handle SISO or SIMO systems only. For estimation of MIMO systems, consider using state-space based methods and convert the result to a transfer function using `tf` after estimation if required. 

### Statespace
The function [`subspaceid`](@ref) handles frequency-domain data (as well as time-domain data). If an [`InputOutputFreqData`](@ref) is passed (may be created with function [`iddata`](@ref)), a frequency-domain method is automatically used. Further, a frequency-response object, [`FRD`](@ref), may also be passed, in which case it is transformed to an `InputOutputFreqData` automatically. If the frequency-response data stems from a frequency-response analysis, you may need to perform a bilinear transform on the frequency axis of the data object to convert the continuous-time frequency axis to discrete time, example:
```julia
Ts    = 0.01 # Sample time
frd_d = c2d(frd_c::FRD, Ts) # Perform a bilinear transformation to discrete-time frequency vector
Ph, _ = subspaceid(frd_d, Ts, nx)
```

The following example generates simulated frequency-response data `frd` from a random system, this data could in practice have come from a frequency-response analysis. We then use the data to fit a model using subspace-based identification in the frequency domain using [`subspaceid`](@ref).
```@example subspacefreq
using ControlSystemIdentification, ControlSystemsBase, Plots
ny,nu,nx = 2,3,5                        # number of outputs, inputs and states
Ts = 1                                  # Sample time
G = ssrand(ny,nu,nx; Ts, proper=true)   # Generate a random system

N = 200             # Number of frequency points
w = freqvec(Ts, N)
frd = FRD(w, G)     # Build a frequency-response data object (this should in practice come from an experiment) 

Gh, x0 = subspaceid(frd, G.Ts, nx; zeroD=true) # Fit frequency response
sigmaplot([G, Gh], w[2:end], lab=["True system" "Estimated model"])
```

## Model-based spectral estimation
The model estimation procedures can be used to estimate spectrograms. This package extends some methods from DSP.jl to accept a estimation function as the second argument. To create a suitable such function, we provide the function [`model_spectrum`](@ref). Usage is illustrated below.
```julia
using ControlSystemIdentification, DSP
T  = 1000
fs = 1
s = sin.((1:1/fs:T) .* 2pi/10) + 0.5randn(T)
S1 = spectrogram(s,window=hanning, fs=fs)            # Standard spectrogram
estimator = model_spectrum(ar,1/fs,6)
S2 = spectrogram(s,estimator,window=rect, fs=fs)     # Model-based spectrogram
plot(plot(S1,title="Standard Spectrogram"),plot(S2,title="AR Spectrogram")) # Requires the package LPVSpectral.jl
```
![window](https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/figs/ar_spectrogram.svg?raw=true)



```@docs
ControlSystemIdentification.tfest
ControlSystemIdentification.coherence
ControlSystemIdentification.laguerre_oo
ControlSystemIdentification.model_spectrum
```