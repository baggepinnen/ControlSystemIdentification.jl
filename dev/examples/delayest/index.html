<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Delay estimation · ControlSystemIdentification Documentation</title><meta name="title" content="Delay estimation · ControlSystemIdentification Documentation"/><meta property="og:title" content="Delay estimation · ControlSystemIdentification Documentation"/><meta property="twitter:title" content="Delay estimation · ControlSystemIdentification Documentation"/><meta name="description" content="Documentation for ControlSystemIdentification Documentation."/><meta property="og:description" content="Documentation for ControlSystemIdentification Documentation."/><meta property="twitter:description" content="Documentation for ControlSystemIdentification Documentation."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystemIdentification Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../iddata/">Identification data</a></li><li><a class="tocitem" href="../../ss/">State-space estimation</a></li><li><a class="tocitem" href="../../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../../impulse/">Impulse-response estimation</a></li><li><a class="tocitem" href="../../freq/">Frequency-domain estimation</a></li><li><a class="tocitem" href="../../validation/">Validation</a></li><li><a class="tocitem" href="../../nonlinear/">Nonlinear identification</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../temp/">Temperature control</a></li><li><a class="tocitem" href="../closed_loop_id/">Identification in closed loop</a></li><li><a class="tocitem" href="../unstable_systems/">Identification of unstable systems</a></li><li class="is-active"><a class="tocitem" href>Delay estimation</a><ul class="internal"><li><a class="tocitem" href="#Estimating-the-delay"><span>Estimating the delay</span></a></li><li><a class="tocitem" href="#Handling-the-delay-when-estimating-a-model"><span>Handling the delay when estimating a model</span></a></li><li><a class="tocitem" href="#Internal-delays"><span>Internal delays</span></a></li></ul></li><li><a class="tocitem" href="../ballandbeam/">Ball and beam</a></li><li><a class="tocitem" href="../flexible_robot/">Flexible robot arm</a></li><li><a class="tocitem" href="../glass_furnace/">Glass furnace</a></li><li><a class="tocitem" href="../evaporator/">Evaporator</a></li><li><a class="tocitem" href="../hair_dryer/">Hair dryer</a></li><li><a class="tocitem" href="../varx/">VARX model</a></li><li><a class="tocitem" href="../hammerstein_wiener/">Nonlinear belt drive</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Delay estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Delay estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/examples/delayest.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Delay-estimation"><a class="docs-heading-anchor" href="#Delay-estimation">Delay estimation</a><a id="Delay-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Delay-estimation" title="Permalink"></a></h1><p>A frequent property of control systems is the presence of <em>delays</em>, either due to processing time, network latency, or other physical phenomena. Delays that occur internally in the system will in the discrete-time setting add a potentially large number of states to the system, <span>$\tau / T_s$</span> state variables are required to represent a delay of <span>$\tau$</span> seconds in a discrete-time system with sampling time <span>$T_s$</span>. A common special case is that the delay occurs at either the input or the output of the system, e.g, due to communication delays. Estimating this delay ahead of the estimation of the model is often beneficial, since it reduces the number of parameters that need to be estimated. Below, we generate a dataset with a large input delay <span>$\tau$</span> and have a look at how we can estimate <span>$\tau$</span>.</p><h2 id="Estimating-the-delay"><a class="docs-heading-anchor" href="#Estimating-the-delay">Estimating the delay</a><a id="Estimating-the-delay-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-the-delay" title="Permalink"></a></h2><pre><code class="language-julia hljs">using DelimitedFiles, Plots
using ControlSystemIdentification, ControlSystemsBase

τ  = 2.0 # Delay in seconds
Ts = 0.1 # Sampling time
P  = c2d(tf(1, [1, 0.5, 1])*delay(τ), Ts) # Dynamics is given by a simple second-order system with input delay

u   = sin.(0.1 .* (0:Ts:30).^2) # An interesting input signal
res = lsim(P, u&#39;, x0=[0.5; 0; zeros(20)])
d   = iddata(res)
plot(d)</code></pre><img src="35c75cb4.svg" alt="Example block output"/><p>If we inspect the (discrete-time) system, we see that it indeed has a large-dimensional state:</p><pre><code class="language-julia hljs">P.nx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">22</code></pre><p>A simple, non-parametric way of figuring out whether or not there&#39;s a delay in the system is to look at the cross-correlation between the input and the output, we can do this using the <a href="../../api/#ControlSystemIdentification.crosscorplot"><code>crosscorplot</code></a> function:</p><pre><code class="language-julia hljs">crosscorplot(d)</code></pre><img src="a2ca9e94.svg" alt="Example block output"/><p>The plot indicates that there is insignificant (below the dashed lines) correlation between the input and the output for lags smaller than 2 seconds, corresponding exactly to our delay <span>$\tau$</span>. </p><p>Another method to identify the delay would be to estimate the impulse response of the system:</p><pre><code class="language-julia hljs">impulseestplot(d, 60; λ=0.5, lab=&quot;Estimated&quot;, title=&quot;Impulse response of delay system&quot;)
plot!(impulse(P, 6), lab=&quot;True&quot;, framestyle=:zerolines)</code></pre><img src="45d04f0f.svg" alt="Example block output"/><p>Estimation of impulse responses in the presence of such large delays is numerically challenging, and a regularization of <span>$λ=0.5$</span> was required to achieve a reasonable result. If the delay is expected to be large and the dataset is small, it is thus recommended to use the cross-correlation method instead, since we cannot tune the regularization parameter <span>$λ$</span> in a practical setting when we don&#39;t know what impulse response to expect. However, for short delays and large datasets, the impulse-response method works rather well. Below, we show the estimated impulse response for a much larger dataset just to demonstrate:</p><pre><code class="language-julia hljs">u2 = sin.(0.01 .* (0:Ts:300).^2) .+ randn.() # An interesting and long input signal with some noise as well
res2 = lsim(P, u2&#39;)
d2 = iddata(res2)

impulseestplot(d2, 200; λ=0.0, lab=&quot;Estimated&quot;, title=&quot;Impulse response with large dataset&quot;)
plot!(impulse(P, 20), lab=&quot;True&quot;, framestyle=:zerolines)</code></pre><img src="b10ac98b.svg" alt="Example block output"/><p>A third method, arguably less elegant, is to use a model-selection method to figure out the delay. Presumably, models estiamted with an order smaller than the delay will be rather poor, something that should be visible if we try models of many orders. Below, we use the function <a href="../../api/#ControlSystemIdentification.find_nanb"><code>find_nanb</code></a> that tries to identify the appropriate model order for an <a href="../../tf/#ControlSystemIdentification.arx"><code>arx</code></a> model.</p><pre><code class="language-julia hljs">find_nanb(d, 2:8, 10:30, xrotation=90, size=(800, 300), margin=5Plots.mm, xtickfont=6)</code></pre><img src="648bdea2.svg" alt="Example block output"/><p>The plot indicates that the Akaike information criterion (AIC) is minimized when <code>nb</code> reaches 22, which happens to be the number of delay samples <span>$\tau / T_s$</span> + the number of numerator parameters for the system without delay:</p><pre><code class="language-julia hljs">c2d(tf(1, [1, 0.5, 1]), Ts)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransferFunction{Discrete{Float64}, ControlSystemsBase.SisoRational{Float64}}
  0.004913614996952642z + 0.004832374721150279
-------------------------------------------------
1.0z^2 - 1.9414834347826107z + 0.9512294245007139

Sample Time: 0.1 (seconds)
Discrete-time transfer function model</code></pre><h2 id="Handling-the-delay-when-estimating-a-model"><a class="docs-heading-anchor" href="#Handling-the-delay-when-estimating-a-model">Handling the delay when estimating a model</a><a id="Handling-the-delay-when-estimating-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-the-delay-when-estimating-a-model" title="Permalink"></a></h2><p>Once we know that there is a delay present, we need to somehow handle it while estimating a model. The naive way is to simply select a model with high-enough order and call it a day. However, this is prone to numerical problems and generally not recommended. Some methods have a dedicated <code>inputdelay</code> keyword that allows you to specify known input delays, after which the method handles it internally. For methods that do not have this option, one can always preprocess the data to remove the delay, we show how to do this next:</p><pre><code class="language-julia hljs">τ_samples = 20 # Number of samples delay
d2 = iddata(d.y[:, τ_samples+1:end], d.u[:, 1:end-τ_samples], d.Ts)
crosscorplot(d2)</code></pre><img src="d27103e5.svg" alt="Example block output"/><p>The cross-correlation plot now indicates that the delay is gone. Please note, one sample delay is most of the time expected, indeed, it&#39;s unrealistic for the output of a physical system to respond at the same time as something happens at the input. Once we have estimated a model with the dataset with the delay removed, we must add the delay back into the estimated model, e.g.,</p><pre><code class="language-julia hljs">P̂ = subspaceid(d2, focus=:simulation) # Estimate a model without delay
tf(d2c(P̂)) # Does it match the original continuous-time system without delay?</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransferFunction{Continuous, ControlSystemsBase.SisoRational{Float64}}
-4.580941551083903e-16s^2 + 0.03693589747814351s + 0.9989182628886228
---------------------------------------------------------------------
          1.0s^2 + 0.5000000000000029s + 0.999999999999998

Continuous-time transfer function model</code></pre><p>The estimated model above should be very close to the system <code>tf(1, [1, 0.5, 1])</code> (some small higher-order terms in the numerator are expected). To add the delay to this model, we do</p><pre><code class="language-julia hljs">P̂τ = P̂*delay(τ, Ts) # Note that this is different from delay(τ, Ts)*P̂ which adds output delay instead of input delay
bodeplot([P, P̂τ], lab=[&quot;True system&quot; &quot;&quot; &quot;Estimated system&quot; &quot;&quot;])</code></pre><img src="81803287.svg" alt="Example block output"/><p>The estimated model should now match the true system very well, including the large drop in phase for higher frequencies due to the delay.</p><div class="admonition is-warning"><header class="admonition-header">Internal delays</header><div class="admonition-body"><p>If the system contains internal delays, it might appear in a cross-correlation plot as if the system has an input-output delay, but in this case shifting the data like we did above may be ill-advised. With internal delays, use the number of estimated delay samples as a lower bound on the model order instead. An example of an internal delay is when a control loop is closed around a delayed channel, illustrated below.</p></div></div><h2 id="Internal-delays"><a class="docs-heading-anchor" href="#Internal-delays">Internal delays</a><a id="Internal-delays-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-delays" title="Permalink"></a></h2><p>In discrete time, a one-sample delay on either the input or the output appear as a pole in the origin. However, when the delay is internal to the system, it&#39;s not as easy to detect. Below, we close the loop around the system <span>$P$</span> from above using a PI controller <span>$C$</span>, and construct a new dataset where the input is the reference to the PI controller rather than the input to the plant. </p><pre><code class="language-julia hljs">C = pid(0.1, 0.5; Ts)
L = P*C
G = feedback(L)
plot(nyquistplot(L), plot(step(G, 50)))</code></pre><img src="cc30f094.svg" alt="Example block output"/><pre><code class="language-julia hljs">ref = sign.(sin.(0.02 .* (0:Ts:50).^2)) # An interesting reference signal
res = lsim(G, ref&#39;)
dG = iddata(res)
plot(plot(dG), crosscorplot(dG))</code></pre><img src="cccc0f41.svg" alt="Example block output"/><p>We see that the cross-correlation plot still indicates that it takes over 2 seconds for the output to be affected by the input, but if we look at the model-selection plot, we must include orders up to above 23 to get a good fit:</p><pre><code class="language-julia hljs">find_nanb(dG, 3:30, 5:30, xrotation=90, size=(800, 300), margin=5Plots.mm, xtickfont=6)</code></pre><img src="73359d75.svg" alt="Example block output"/><p>We can also inspect the pole-zero maps of the open-loop and closed-loop systems</p><pre><code class="language-julia hljs">plot(
    pzmap(P, title=&quot;Open-loop system&quot;),
    pzmap(G, title=&quot;Closed-loop system&quot;),
    plot_title=&quot;Pole-zero maps&quot;,
    layout=(1, 2),
    ratio=:equal,
    size=(800, 400),
    xlims=(-1.1, 1.1),
    ylims=(-1.1, 1.1),
)</code></pre><img src="1773b187.svg" alt="Example block output"/><p>the presence of the feedback has moved all the delay poles away from the origin (there are multiple poles on top of each other in the left plot).</p><p>In this case, we must thus estimate a model of fairly high order (23) in order to accurately capture the dynamics of the system. If we do this, we can see that the estimated model matches the true system very well (since we didn&#39;t add any disturbance):</p><pre><code class="language-julia hljs">model = subspaceid(dG, G.nx)
simplot(model, dG, zeros(model.nx))</code></pre><img src="dc012403.svg" alt="Example block output"/><p>In a practical scenario, estimating a model of such high order may be difficult. It might then be worthwhile trying to estimate the lower-order open-loop system <span>$P$</span> directly, taking care to properly handle the delay, which then appears on the input rather than internally.</p><p>If we use one of the methods that support the <code>inputdelay</code> keyword, we can see whether or not we can approximate the closed-loop system with a model that has an input delay only:</p><pre><code class="language-julia hljs">model2 = arx(dG, 4, 4, inputdelay=τ_samples)
plot(
    simplot(model2, dG),
    pzmap(
        model2,
        ratio=:equal,
        xlims=(-1.1, 1.1),
        ylims=(-1.1, 1.1),
        title=&quot;Estimated ARX model with input delay&quot;,
    )
)</code></pre><img src="2d2dc8bc.svg" alt="Example block output"/><p>We see that with a model of order 3 (4 free parameters in the denominator) together with a specified input delay of 20 samples, we indeed get a good approximation of the closed-loop system.</p><p>If we compare the Bode plots of the true closed-loop system with the two identified models, they match very well.</p><pre><code class="language-julia hljs">bodeplot([G, model, model2])</code></pre><img src="3417fe9b.svg" alt="Example block output"/><p>It may thus be possible to approximate a system with internal delays using a model that has an input delay only.</p><p>For completeness, we construct an example where this is not quite possible. The system in the example below can be thought of as an echo chamber, where the input passes through a resonant channel before it reaches the output. 60% of the output energy is fed back at the input through the same channel (the echo), causing an interesting impulse response:    </p><pre><code class="language-julia hljs">ref = sign.(sin.(0.02 .* (0:Ts:100).^2)) # An interesting reference signal
Pc = feedback(tf(100, [1, 10, 100]), -tf(60, [1, 10, 100])*delay(τ)) # Feed 60% of the output back at the input with a delay of 2 seconds (like an echo)
Pd = c2d(Pc, Ts)
res = lsim(Pd, ref&#39;)
decho = iddata(res)
plot(bodeplot(Pd, lab=&quot;&quot;), pzmap(Pd), plot(impulse(Pd, 10), title=&quot;Impulse response&quot;), plot(decho))</code></pre><img src="9599de71.svg" alt="Example block output"/><p>The model-selection plot below indicates that we need to reach model orders of 24 to get a good fit</p><pre><code class="language-julia hljs">find_nanb(decho, 3:30, 5:30, xrotation=90, size=(800, 300), margin=5Plots.mm, xtickfont=6)</code></pre><img src="87034485.svg" alt="Example block output"/><p>trying to estimate a 4:th order model with input delay of 20 samples does not work at all this time, but fitting a 24:th order model does, and fitting a 4:th order model using subspace identification with a long internal prediction horizon works reasonably well</p><pre><code class="language-julia hljs">model3 = arx(decho, 4, 4, inputdelay=τ_samples)
model4 = subspaceid(decho, 24)
model5 = subspaceid(decho, 4, r=50)
figsim = simplot(model3, decho, zeros(ss(model3).nx), sysname=&quot;ARX 4&quot;)
simplot!(model4, decho, zeros(model4.nx), ploty=false, plotu=false, sysname=&quot;Subspace 24&quot;)
simplot!(model5, decho, zeros(model5.nx), ploty=false, plotu=false, sysname=&quot;Subspace 4&quot;)</code></pre><img src="e182f34c.svg" alt="Example block output"/><p>Keep in mind that we do not add any disturbance in our simulations here, and estimating 24:th order models is likely going to be a challenging task in practice.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../unstable_systems/">« Identification of unstable systems</a><a class="docs-footer-nextpage" href="../ballandbeam/">Ball and beam »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 8 May 2024 05:41">Wednesday 8 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
