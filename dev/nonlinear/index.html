<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear identification · ControlSystemIdentification Documentation</title><meta name="title" content="Nonlinear identification · ControlSystemIdentification Documentation"/><meta property="og:title" content="Nonlinear identification · ControlSystemIdentification Documentation"/><meta property="twitter:title" content="Nonlinear identification · ControlSystemIdentification Documentation"/><meta name="description" content="Documentation for ControlSystemIdentification Documentation."/><meta property="og:description" content="Documentation for ControlSystemIdentification Documentation."/><meta property="twitter:description" content="Documentation for ControlSystemIdentification Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ControlSystemIdentification Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iddata/">Identification data</a></li><li><a class="tocitem" href="../ss/">State-space estimation</a></li><li><a class="tocitem" href="../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../impulse/">Impulse-response estimation</a></li><li><a class="tocitem" href="../freq/">Frequency-domain estimation</a></li><li><a class="tocitem" href="../validation/">Validation</a></li><li class="is-active"><a class="tocitem" href>Nonlinear identification</a><ul class="internal"><li><a class="tocitem" href="#Parameter-estimation-in-a-known-model-structure"><span>Parameter estimation in a known model structure</span></a></li><li><a class="tocitem" href="#Identifying-parameters-in-a-ModelingToolkit-model"><span>Identifying parameters in a ModelingToolkit model</span></a></li><li><a class="tocitem" href="#Hammerstein-Wiener-estimation"><span>Hammerstein-Wiener estimation</span></a></li><li class="toplevel"><a class="tocitem" href="#Video-tutorials"><span>Video tutorials</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/temp/">Temperature control</a></li><li><a class="tocitem" href="../examples/closed_loop_id/">Identification in closed loop</a></li><li><a class="tocitem" href="../examples/unstable_systems/">Identification of unstable systems</a></li><li><a class="tocitem" href="../examples/delayest/">Delay estimation</a></li><li><a class="tocitem" href="../examples/ballandbeam/">Ball and beam</a></li><li><a class="tocitem" href="../examples/flexible_robot/">Flexible robot arm</a></li><li><a class="tocitem" href="../examples/glass_furnace/">Glass furnace</a></li><li><a class="tocitem" href="../examples/evaporator/">Evaporator</a></li><li><a class="tocitem" href="../examples/hair_dryer/">Hair dryer</a></li><li><a class="tocitem" href="../examples/varx/">VARX model</a></li><li><a class="tocitem" href="../examples/hammerstein_wiener/">Nonlinear belt drive</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Nonlinear identification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear identification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/nonlinear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Identification-of-nonlinear-models"><a class="docs-heading-anchor" href="#Identification-of-nonlinear-models">Identification of nonlinear models</a><a id="Identification-of-nonlinear-models-1"></a><a class="docs-heading-anchor-permalink" href="#Identification-of-nonlinear-models" title="Permalink"></a></h1><p>This package supports two forms of nonlinear system identification.</p><ul><li>Parameter estimation in a known model structure (linear or nonlinear) <span>$x⁺ = f(x, u, p)$</span> where <code>p</code> is a vector of parameters to be estimated.</li><li>Estimation of Hammerstein-Wiener models, i.e., linear systems with static nonlinear functions on the input and/or output.</li></ul><h2 id="Parameter-estimation-in-a-known-model-structure"><a class="docs-heading-anchor" href="#Parameter-estimation-in-a-known-model-structure">Parameter estimation in a known model structure</a><a id="Parameter-estimation-in-a-known-model-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-estimation-in-a-known-model-structure" title="Permalink"></a></h2><p>Parameter estimation in differential equations can be performed by forming a one-step ahead predictor of the output, and minimizing the prediction error. This procedure is packaged in the function <a href="#ControlSystemIdentification.nonlinear_pem"><code>ControlSystemIdentification.nonlinear_pem</code></a> which is available as a package extension, available if the user manually installs and loads <a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim.jl</a>.</p><p>The procedure to use this function is as follows</p><ol><li>The dynamics is specified on the form <span>$x_{k+1} = f(x_k, u_k, p, t)$</span> or <span>$ẋ = f(x, u, p, t)$</span> where <span>$x$</span> is the state, <span>$u$</span> the input,  <code>p</code> is a vector of parameters to be estimated and <span>$t$</span> is time.</li><li>If the dynamics is in continuous time (a differential equation or differential-algebraic equation), use the package <a href="https://github.com/baggepinnen/SeeToDee.jl">SeeToDee.jl</a> to <em>discretize</em> it. If the dynamics is already in discrete time, skip this step.</li><li>Define the measurement function <span>$y = h(x, u, p, t)$</span> that maps the state and input to the measured output.</li><li>Specify covariance properties of the dynamics noise and measurement noise, similar to how one would do when building a Kalman filter for a linear system.</li><li>Perform the estimation using <a href="#ControlSystemIdentification.nonlinear_pem"><code>ControlSystemIdentification.nonlinear_pem</code></a>.</li></ol><p>Internally, <a href="#ControlSystemIdentification.nonlinear_pem"><code>ControlSystemIdentification.nonlinear_pem</code></a> constructs an Unscented Kalman filter (UKF) from the package <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl">LowLevelParticleFilters.jl</a> in order to perform state estimation along the provided data trajectory. An optimization problem is then solved in order to find the parameters (and optionally initial condition) that minimizes the prediction errors. This procedure is somewhat different from simply finding the parameters that make a pure simulation of the system match the data, notably, the prediction-error approach can usually handle very poor initial guesses, unstable systems and even chaotic systems. To learn more about the prediction-error method, see the tutorial <a href="../examples/unstable_systems/#Properties-of-the-Prediction-Error-Method">Properties of the Prediction-Error Method</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemIdentification.nonlinear_pem" href="#ControlSystemIdentification.nonlinear_pem"><code>ControlSystemIdentification.nonlinear_pem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonlinear_pem(
    d::IdData,
    discrete_dynamics,
    measurement,
    p0,
    x0,
    R1,
    R2,
    nu;
    optimizer = LevenbergMarquardt(),
    λ = 1.0,
    optimize_x0 = true,
    kwargs...,
)</code></pre><p>Nonlinear Prediction-Error Method (PEM).</p><p>This method attempts to find the optimal vector of parameters, <span>$p$</span>, and the initial condition <span>$x_0$</span>, that minimizes the sum of squared one-step prediction errors. The prediction is performed using an Unscented Kalman Filter (UKF) and the optimization is performed using a Gauss-Newton method. </p><div class="admonition is-info"><header class="admonition-header">Requires LeastSquaresOptim.jl</header><div class="admonition-body"><p>This function is available only if LeastSquaresOptim.jl is manually installed and loaded by the user.</p></div></div><p><strong>Arguments:</strong></p><ul><li><code>d</code>: Identification data</li><li><code>discrete_dynamics</code>: A dynamics function <code>(xₖ, uₖ, p, t) -&gt; x(k+1)</code> that takes the current state <code>x</code>, input <code>u</code>, parameters <code>p</code>, and time <code>t</code> and returns the next state <code>x(k+1)</code>.</li><li><code>measurement</code>: The measurement / output function of the nonlinear system <code>(xₖ, uₖ, p, t) -&gt; yₖ</code></li><li><code>p0</code>: The initial guess for the parameter vector</li><li><code>x0</code>: The initial guess for the initial condition</li><li><code>R1</code>: Dynamics noise covariance matrix (increasing this makes the algorithm trust the model less)</li><li><code>R2</code>: Measurement noise covariance matrix (increasing this makes the algorithm trust the measurements less)</li><li><code>nu</code>: Number of inputs to the system</li><li><code>optimizer</code>: Any optimizer from <a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim</a></li><li><code>λ</code>: A weighting factor to minimize <code>dot(e, λ, e</code>). A commonly used metric is <code>λ = Diagonal(1 ./ (mag.^2))</code>, where <code>mag</code> is a vector of the &quot;typical magnitude&quot; of each output. Internally, the square root of <code>W = sqrt(λ)</code> is calculated so that the residuals stored in <code>res</code> are <code>W*e</code>.</li><li><code>optimize_x0</code>: Whether to optimize the initial condition <code>x0</code> or not. If <code>false</code>, the initial condition is fixed to the value of <code>x0</code> and the optimization is performed only on the parameters <code>p</code>.</li></ul><p>The inner optimizer accepts a number of keyword arguments:</p><ul><li><code>lower</code>: Lower bounds for the parameters and initial condition (if optimized). If <code>x0</code> is optimized, this is a vector with layout <code>[lower_p; lower_x0]</code>.</li><li><code>upper</code>: Upper bounds for the parameters and initial condition (if optimized). If <code>x0</code> is optimized, this is a vector with layout <code>[upper_p; upper_x0]</code>.</li><li><code>x_tol = 1e-8</code></li><li><code>f_tol = 1e-8</code></li><li><code>g_tol = 1e-8</code></li><li><code>iterations = 1_000</code></li><li><code>Δ = 10.0</code></li><li><code>store_trace = false</code></li></ul><p>See <a href="https://baggepinnen.github.io/ControlSystemIdentification.jl/dev/nonlinear/">Identification of nonlinear models</a> for more details.</p><div class="admonition is-warning"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>This function is considered experimental and may change in the future without respecting semantic versioning. This implementation also lacks a number of features associated with good nonlinear PEM implementations, such as regularization and support for multiple datasets.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/56984f07ac48e53146059d505d3e00d0cadd9011/src/pem.jl#L582-L633">source</a></section></article><h3 id="Example:-Quad-tank"><a class="docs-heading-anchor" href="#Example:-Quad-tank">Example: Quad tank</a><a id="Example:-Quad-tank-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Quad-tank" title="Permalink"></a></h3><p>This example considers a quadruple tank, where two upper tanks feed liquid into two lower tanks, depicted in the schematics below. The quad-tank process is a well-studied example in many multivariable control courses, this particular instance of the process is borrowed from the Lund University <a href="https://control.lth.se/education/engineering-program/frtf05-automatic-control-basic-course-for-fipi/">introductory course on automatic control</a>.</p><p><img src="https://user-images.githubusercontent.com/3797491/166203096-40539c68-5657-4db3-bec6-f893286056e1.png" alt="process"/></p><p>The process has a <em>cross coupling</em> between the tanks, governed by a parameters <span>$\gamma_i$</span>: The flows from the pumps are divided according to the two parameters <span>$γ_1 , γ_2 ∈ [0, 1]$</span>. The flow to tank 1 is <span>$γ_1 k_1u_1$</span> and the flow to tank 4 is <span>$(1 - γ_1 )k_1u_1$</span>. Tanks 2 and 3 behave symmetrically.</p><p>The dynamics are given by</p><p class="math-container">\[\begin{aligned}
\dot{h}_1 &amp;= \dfrac{-a_1}{A_1}   \sqrt{2g h_1} + \dfrac{a_3}{A_1} \sqrt{2g h_3} +     \dfrac{γ_1 k_1}{A_1}   u_1 \\
\dot{h}_2 &amp;= \dfrac{-a_2}{A_2}   \sqrt{2g h_2} + \dfrac{a_4}{A_2} \sqrt{2g h_4} +     \dfrac{γ_2 k_2}{A_2}   u_2 \\
\dot{h}_3 &amp;= \dfrac{-a_3}{A_3} \sqrt{2g h_3}                         + \dfrac{(1-γ_2) k_2}{A_3}   u_2 \\
\dot{h}_4 &amp;= \dfrac{-a_4}{A_4} \sqrt{2g h_4}                          + \dfrac{(1-γ_1) k_1}{A_4}   u_1
\end{aligned}\]</p><p>where <span>$h_i$</span> are the tank levels and <span>$a_i, A_i$</span> are the cross-sectional areas of outlets and tanks respectively.</p><p>We start by defining the dynamics in continuous time, and discretize them using the integrator <a href="https://baggepinnen.github.io/SeeToDee.jl/dev/api/#SeeToDee.Rk4"><code>SeeToDee.Rk4</code></a> with a sample time of <span>$T_s = 1$</span>s.</p><pre><code class="language-julia hljs">using StaticArrays, SeeToDee

function quadtank(h, u, p, t)
    k1, k2, g = p[1], p[2], 9.81
    A1 = A3 = A2 = A4 = p[3]
    a1 = a3 = a2 = a4 = 0.03
    γ1 = γ2 = p[4]

    ssqrt(x) = √(max(x, zero(x)) + 1e-3) # For numerical robustness at x = 0

    SA[
        -a1/A1 * ssqrt(2g*h[1]) + a3/A1*ssqrt(2g*h[3]) +     γ1*k1/A1 * u[1]
        -a2/A2 * ssqrt(2g*h[2]) + a4/A2*ssqrt(2g*h[4]) +     γ2*k2/A2 * u[2]
        -a3/A3*ssqrt(2g*h[3])                          + (1-γ2)*k2/A3 * u[2]
        -a4/A4*ssqrt(2g*h[4])                          + (1-γ1)*k1/A4 * u[1]
    ]
end
measurement(x,u,p,t) = SA[x[1], x[2]]

Ts = 1.0
discrete_dynamics = SeeToDee.Rk4(quadtank, Ts, supersample=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SeeToDee.Rk4{typeof(Main.quadtank), Float64}(Main.quadtank, 1.0, 2)</code></pre><p>The output from this system is the water level in the first two tanks, i.e., <span>$y = [x_1, x_2]$</span>.</p><p>We also specify the number of state variables, outputs and inputs as well as a vector of &quot;true&quot; parameters, the ones we will try to estimate.</p><pre><code class="language-julia hljs">nx = 4
ny = 2
nu = 2
p_true = [1.6, 1.6, 4.9, 0.2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 1.6
 1.6
 4.9
 0.2</code></pre><p>We then simulate some data from the system to use for identification:</p><pre><code class="language-julia hljs">using ControlSystemIdentification, ControlSystemsBase
using ControlSystemsBase.DemoSystems: resonant
using LowLevelParticleFilters
using LeastSquaresOptim
using Random, Plots, LinearAlgebra

# Generate some data from the system
Random.seed!(1)
Tperiod = 200
t = 0:Ts:1000
u1 = vcat.(0.25 .* sign.(sin.(2pi/Tperiod .* (t ./ 40).^2)) .+ 0.25)
u2 = vcat.(0.25 .* sign.(sin.(2pi/Tperiod .* (t ./ 40).^2 .+ pi/2)) .+ 0.25)
u  = vcat.(u1,u2)
u = [u; 0 .* u[1:100]]
x0 = [2.5, 1.5, 3.2, 2.8]
x = LowLevelParticleFilters.rollout(discrete_dynamics, x0, u, p_true)[1:end-1]
y = measurement.(x, u, 0, 0)
y = [y .+ 0.5randn(ny) for y in y] # Add some measurement noise
Y = reduce(hcat, y) # Go from vector of vectors to a matrix
U = reduce(hcat, u) # Go from vector of vectors to a matrix
plot(
    plot(reduce(hcat, x)&#39;, title=&quot;States&quot;, lab=[&quot;h1&quot; &quot;h2&quot; &quot;h3&quot; &quot;h4&quot;]),
    plot(U&#39;, title=&quot;Inputs&quot;, lab=[&quot;u1&quot; &quot;u2&quot;]),
    plot(Y&#39;, title=&quot;Outputs&quot;, lab=[&quot;y1&quot; &quot;y2&quot;]),
)</code></pre><img src="b9bd1b13.svg" alt="Example block output"/><p>We package the experimental data into an <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a> object as usual. Finally, we specify the covariance matrices for the dynamics noise and measurement noise as well as a guess for the initial condition. Since we can measure the level in the first two tanks, we use the true initial condition for those tanks, but we pretend that we are quite off when guessing the initial condition for the last two tanks. </p><p>Choosing the covariance matrices can be non-trivial, see the blog post <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">How to tune a Kalman filter</a> for some background. Here, we pick some value for <span>$R_1$</span> that seems reasonable, and pick a deliberately large value for <span>$R_2$</span>. Choosing a large covariance of the measurement noise will lead to the state estimator trusting the measurements less, which in turns leads to a smaller feedback correction. This will make the algorithm favor a model that is good at simulation, rather than focusing exclusively on one-step prediction.</p><p>Finally, we call the function <a href="#ControlSystemIdentification.nonlinear_pem"><code>ControlSystemIdentification.nonlinear_pem</code></a> to perform the estimation.</p><pre><code class="language-julia hljs">d = iddata(Y, U, Ts)
x0_guess = [2.5, 1.5, 1, 2] # Guess for the initial condition
p_guess = [1.4, 1.4, 5.1, 0.25] # Initial guess for the parameters

R1 = Diagonal([0.1, 0.1, 0.1, 0.1])
R2 = 100*Diagonal(0.5^2 * ones(ny))

model = ControlSystemIdentification.nonlinear_pem(d, discrete_dynamics, measurement, p_guess, x0_guess, R1, R2, nu)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonlinearPredictionErrorModel
  p: [1.613059566228807, 1.5994574203026608, 4.886961965816998, 0.20432997287915097]
  x0: [2.5585064512007656, 1.6722780052530601, 2.8780227166393195, 2.092408142173945]
  Ts: 1.0
  ny = 2, nu = 2, nx = 4
</code></pre><p>We can then test how the model performs on the data, and compare with the model corresponding to our initial guess</p><pre><code class="language-julia hljs">simplot(model, d, layout=2)

x_guess = LowLevelParticleFilters.rollout(discrete_dynamics, x0_guess, u, p_guess)[1:end-1]
y_guess = measurement.(x_guess, u, 0, 0)
plot!(reduce(hcat, y_guess)&#39;, lab=&quot;Initial guess&quot;)</code></pre><img src="8472aee4.svg" alt="Example block output"/><p>We can also perform a residual analysis to see if the model is able to capture the dynamics of the system</p><pre><code class="language-julia hljs">residualplot(model, d)</code></pre><img src="e8d4756a.svg" alt="Example block output"/><p>since we are using simulated data here, the residuals are white and there&#39;s nothing to worry about. In practice, one should always inspect the residuals to see if there are any systematic errors in the model.</p><p>Internally, the returned model object contains the estimated parameters, let&#39;s see if they are any good</p><pre><code class="language-julia hljs">[p_true p_guess model.p]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×3 Matrix{Float64}:
 1.6  1.4   1.61306
 1.6  1.4   1.59946
 4.9  5.1   4.88696
 0.2  0.25  0.20433</code></pre><p>hopefully, the estimated parameters are close to the true ones.</p><p>To customize the implementation of the nonlinear prediction-error method, see a lower-level interface being used in the tutorial <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/parameter_estimation/#Using-an-optimizer">in the documentation of LowLevelParticleFilters.jl</a> which also provides the UKF.</p><h2 id="Identifying-parameters-in-a-ModelingToolkit-model"><a class="docs-heading-anchor" href="#Identifying-parameters-in-a-ModelingToolkit-model">Identifying parameters in a ModelingToolkit model</a><a id="Identifying-parameters-in-a-ModelingToolkit-model-1"></a><a class="docs-heading-anchor-permalink" href="#Identifying-parameters-in-a-ModelingToolkit-model" title="Permalink"></a></h2><p>The following shows how to use <code>nonlinear_pem</code> to estimate the parameters of an ModelingToolkit model. This example is a continuation of the quadruple-tank example above, and we&#39;ll reuse the same data generated previously.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>ModelingToolkit is a fast moving target that breaks frequently. The example below was tested with ModelingToolkit v9.23, but is not run as part of the build process for this documentation and is not to be considered a supported interface between ControlSystemIdentification and ModelingToolkit.</p></div></div><p>When we define the MTK model, we give defaults for all parameters. We then specify the inputs and outputs of this model, since they are arrays in this example, we call <code>collect</code> to turn them into scalars. To obtain a dynamics function on the form <span>$\dot x = f(x, u, p, t)$</span> from MTK, we call <code>ModelingToolkit.generate_control_function</code>. This returns two versions of this function, where the other one operates in place. This function also returns the state variables chosen, the parameters of the model as well as a simplified system with inputs and outputs. The function returned from <code>ModelingToolkit.generate_control_function</code> expects all the parameters of the system to be provided, but we only want to optimize a few of them. We thus wrap this function in <code>discrete_dynamics_mtk</code> in order to insert the optimized parameters into a parameter array that contains also the non-optimized parameters. We make use of the function <code>similar</code> to ensure that the final parameter array has the correct type (Dual numbers for AD will be used).</p><p>For good performance, we wrap all the glue code in a function <code>estimate_model_mtk</code> so that we avoid the use of too many global variables.</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: D_nounits as D
t = ModelingToolkit.t_nounits
ssqrt(x) = √(max(x, zero(x)) + 1e-3) # For numerical robustness at x = 0
@register_symbolic ssqrt(x)

@mtkmodel QuadtankModel begin
    @parameters begin
        k1 = 1.4
        k2 = 1.4
        g = 9.81
        A = 5.1
        a = 0.03
        γ = 0.25
    end
    begin
        A1 = A2 = A3 = A4 = A
        a1 = a3 = a2 = a4 = a
        γ1 = γ2 = γ
    end
    @variables begin
        h(t)[1:4] = 0
        u(t)[1:2] = 0
    end
    @equations begin
        D(h[1]) ~ -a1/A1 * ssqrt(2g*h[1]) + a3/A1*ssqrt(2g*h[3]) +     γ1*k1/A1 * u[1]
        D(h[2]) ~ -a2/A2 * ssqrt(2g*h[2]) + a4/A2*ssqrt(2g*h[4]) +     γ2*k2/A2 * u[2]
        D(h[3]) ~ -a3/A3*ssqrt(2g*h[3])                          + (1-γ2)*k2/A3 * u[2]
        D(h[4]) ~ -a4/A4*ssqrt(2g*h[4])                          + (1-γ1)*k1/A4 * u[1]
    end
end

@named mtkmodel = QuadtankModel()
mtkmodel = complete(mtkmodel)
inputs = [collect(mtkmodel.u);]
outputs = [collect(mtkmodel.h[1:2]);]

function estimate_model_mtk(mtkmodel, inputs, outputs) # A wrapper function to avoid using global variables
    (f_oop, f_ip), statevars, p, io_sys = ModelingToolkit.generate_control_function(mtkmodel, inputs; outputs)
    continuous_dynamics = f_oop
    inner_discrete_dynamics = SeeToDee.Rk4(continuous_dynamics, Ts, supersample=2)

    tunable_p = [mtkmodel.k1, mtkmodel.k2, mtkmodel.A, mtkmodel.γ] # Provided in the same order as p_guess
    tunable_indices = [findfirst(isequal(pi), p) for pi in tunable_p] # Figure out what indices of the parameter array correspond to our tunable parameters
    p0 = [ModelingToolkit.defaults(io_sys)[pi] for pi in p]
    full_p = deepcopy(p0)
    output_indices = [findfirst(isequal(yi), statevars) for yi in outputs] # Figure out what indices of the state array correspond to our outputs

    function discrete_dynamics_wrapper(x, u, p, t)
        opt_p = similar(p, length(full_p)) # Create an array of correct length and element type to host the full parameter vector
        opt_p .= full_p # Write all the initial parameters into this new array
        opt_p[tunable_indices] .= p # Overwrite the tunable parameters with the optimization variable
        inner_discrete_dynamics(x, u, opt_p, t) # Call the discretized dynamics function from MTK
    end

    mtk_measurement(x,u,p,t) = x[output_indices]

    model = ControlSystemIdentification.nonlinear_pem(d, discrete_dynamics_wrapper, mtk_measurement, p_guess, x0_guess, R1, R2, nu)
end

estimate_model_mtk(mtkmodel, inputs, outputs)</code></pre><p>This should result in a similar final cost value as when the dynamics was implemented manually above. </p><h2 id="Hammerstein-Wiener-estimation"><a class="docs-heading-anchor" href="#Hammerstein-Wiener-estimation">Hammerstein-Wiener estimation</a><a id="Hammerstein-Wiener-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Hammerstein-Wiener-estimation" title="Permalink"></a></h2><p>This package provides elementary identification of nonlinear systems on Hammerstein-Wiener form, i.e., systems with a static input nonlinearity and a static output nonlinearity with a linear system in-between, <strong>where the nonlinearities are known</strong>. The only aspect of the nonlinearities that are optionally estimated are parameters. To formalize this, the estimation method <a href="../ss/#ControlSystemIdentification.newpem"><code>newpem</code></a> allows for estimation of a model of the form</p><p class="math-container">\[\begin{aligned}
x^+ &amp;= Ax + B u_{nl} \\
y &amp;= Cx + D u_{nl}   \\
u_{nl} &amp;= g_i(u, p)  \\
y_{nl} &amp;= g_o(y, p)
\end{aligned}\]</p><pre><code class="nohighlight hljs">   ┌─────┐   ┌─────┐   ┌─────┐
 u │     │uₙₗ│     │ y │     │ yₙₗ
──►│  gᵢ ├──►│  P  ├──►│  gₒ ├─►
   │     │   │     │   │     │
   └─────┘   └─────┘   └─────┘</code></pre><p>where <code>g_i</code> and <code>g_o</code> are static, nonlinear functions that may depend on some parameter vector <span>$p$</span> which is optimized together with the matrices <span>$A,B,C,D$</span>. The procedure to estimate such a model is detailed in the docstring for <a href="../ss/#ControlSystemIdentification.newpem"><code>newpem</code></a>.</p><p>The result of this estimation is the linear system <em>without</em> the nonlinearities applied, those must be handled manually by the user.</p><p>The default optimizer BFGS may struggle with problems including nonlinearities. If you do not get good results, try a different optimizer, e.g., <code>optimizer = Optim.NelderMead()</code>.</p><h3 id="Example-with-simulated-data:"><a class="docs-heading-anchor" href="#Example-with-simulated-data:">Example with simulated data:</a><a id="Example-with-simulated-data:-1"></a><a class="docs-heading-anchor-permalink" href="#Example-with-simulated-data:" title="Permalink"></a></h3><p>The example below identifies a model of a resonant system where the sign of the output is unknown, i.e., the output nonlinearity is given by <span>$y_{nl} = |y|$</span>. To make the example a bit more realistic, we also simulate colored measurement and input noise, <code>yn</code> and <code>un</code>. For an example with real data, see <a href="../examples/hammerstein_wiener/#Hammerstein-Wiener-estimation-of-nonlinear-belt-drive-system">Hammerstein-Wiener estimation of nonlinear belt-drive system</a>.</p><pre><code class="language-julia hljs">using ControlSystemIdentification, ControlSystemsBase
using ControlSystemsBase.DemoSystems: resonant
using Random, Plots

# Generate some data from the system
Random.seed!(1)
T = 200
sys = c2d(resonant(ω0 = 0.1) * tf(1, [0.1, 1]), 1)# generate_system(nx, nu, ny)
nx = sys.nx
nu = 1
ny = 1
x0 = zeros(nx)
sim(sys, u, x0 = x0) = lsim(sys, u, 1:T, x0 = x0)[1]
sysn = c2d(resonant(ω0 = 1) * tf(1, [0.1, 1]), 1)

σu = 1e-2 # Input noise standard deviation
σy = 1e-3 # Output noise standard deviation

u  = randn(nu, T)
un = u + sim(sysn, σu * randn(size(u)), 0 * x0)
y  = sim(sys, un, x0)
yn = y + sim(sysn, σy * randn(size(u)), 0 * x0)

# Nonlinear output transformation
ynn = abs.(yn)
d  = iddata(ynn, un, 1)
output_nonlinearity = (y, p) -&gt; y .= abs.(y)

# Estimate 10 models with different random initialization and pick the best one
# If results are poor, try `optimizer = Optim.NelderMead()` instead
results = map(1:10) do _
    sysh, x0h, opt = newpem(d, nx; output_nonlinearity, show_trace=false, focus = :simulation)
    (; sysh, x0h, opt)
end;

(; sysh, x0h, opt) = argmin(r-&gt;r.opt.minimum, results) # Find the model with the smallest cost

yh = simulate(sysh, d, x0h)
output_nonlinearity(yh, nothing) # We need to manually apply the output nonlinearity to the prediction
plot(d.t, [abs.(y); u]&#39;, lab=[&quot;True nonlinear output&quot; &quot;Input&quot;], seriestype = [:line :steps], layout=(2,1), xlabel=&quot;Time&quot;)
scatter!(d.t, ynn&#39;, lab=&quot;Measured nonlinear output&quot;, sp=1)
plot!(d.t, yh&#39;, lab=&quot;Simulation&quot;, sp=1, l=:dash)</code></pre><img src="e31454d8.svg" alt="Example block output"/><h1 id="Video-tutorials"><a class="docs-heading-anchor" href="#Video-tutorials">Video tutorials</a><a id="Video-tutorials-1"></a><a class="docs-heading-anchor-permalink" href="#Video-tutorials" title="Permalink"></a></h1><p>Relevant video tutorials are available here:</p><iframe style="height: 315px; width: 560px" src="https://www.youtube.com/embed/GKl8Tz9n2gs?si=-snSBsubTkq17b0x" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../validation/">« Validation</a><a class="docs-footer-nextpage" href="../examples/temp/">Temperature control »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 23 August 2024 11:52">Friday 23 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
