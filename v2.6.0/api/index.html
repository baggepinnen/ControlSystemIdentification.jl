<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ControlSystemIdentification Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ControlSystemIdentification Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iddata/">Identification data</a></li><li><a class="tocitem" href="../ss/">State-space estimation</a></li><li><a class="tocitem" href="../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../impulse/">Impulse-response estimation</a></li><li><a class="tocitem" href="../freq/">Frequency-domain estimation</a></li><li><a class="tocitem" href="../validation/">Validation</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/temp/">Temperature control</a></li><li><a class="tocitem" href="../examples/closed_loop_id/">Identification in closed loop</a></li><li><a class="tocitem" href="../examples/unstable_systems/">Identification of unstable systems</a></li><li><a class="tocitem" href="../examples/ballandbeam/">Ball and beam</a></li><li><a class="tocitem" href="../examples/flexible_robot/">Flexible robot arm</a></li><li><a class="tocitem" href="../examples/glass_furnace/">Glass furnace</a></li><li><a class="tocitem" href="../examples/evaporator/">Evaporator</a></li><li><a class="tocitem" href="../examples/hair_dryer/">Hair dryer</a></li><li><a class="tocitem" href="../examples/varx/">VARX model</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ControlSystemIdentification.FRD-Tuple{Any, LTISystem}"><code>ControlSystemIdentification.FRD</code></a></li><li><a href="#ControlSystemIdentification.FRD"><code>ControlSystemIdentification.FRD</code></a></li><li><a href="#ControlSystemIdentification.Hz"><code>ControlSystemIdentification.Hz</code></a></li><li><a href="#ControlSystemIdentification.InputOutputData"><code>ControlSystemIdentification.InputOutputData</code></a></li><li><a href="#ControlSystemIdentification.InputOutputFreqData"><code>ControlSystemIdentification.InputOutputFreqData</code></a></li><li><a href="#ControlSystemIdentification.N4SIDStateSpace"><code>ControlSystemIdentification.N4SIDStateSpace</code></a></li><li><a href="#ControlSystemIdentification.PredictionStateSpace"><code>ControlSystemIdentification.PredictionStateSpace</code></a></li><li><a href="#ControlSystemIdentification.rad"><code>ControlSystemIdentification.rad</code></a></li><li><a href="#ControlSystemIdentification.apply_fun"><code>ControlSystemIdentification.apply_fun</code></a></li><li><a href="../tf/#ControlSystemIdentification.ar"><code>ControlSystemIdentification.ar</code></a></li><li><a href="#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.ar</code></a></li><li><a href="../tf/#ControlSystemIdentification.arma"><code>ControlSystemIdentification.arma</code></a></li><li><a href="#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma</code></a></li><li><a href="#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma_ssa</code></a></li><li><a href="../tf/#ControlSystemIdentification.arx"><code>ControlSystemIdentification.arx</code></a></li><li><a href="#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arx</code></a></li><li><a href="#ControlSystemIdentification.arxar-Tuple{InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}"><code>ControlSystemIdentification.arxar</code></a></li><li><a href="../tf/#ControlSystemIdentification.arxar"><code>ControlSystemIdentification.arxar</code></a></li><li><a href="#ControlSystemIdentification.autocorplot"><code>ControlSystemIdentification.autocorplot</code></a></li><li><a href="#ControlSystemIdentification.coherence-Tuple{ControlSystemIdentification.AbstractIdData}"><code>ControlSystemIdentification.coherence</code></a></li><li><a href="../freq/#ControlSystemIdentification.coherence"><code>ControlSystemIdentification.coherence</code></a></li><li><a href="#ControlSystemIdentification.coherenceplot"><code>ControlSystemIdentification.coherenceplot</code></a></li><li><a href="#ControlSystemIdentification.crosscorplot"><code>ControlSystemIdentification.crosscorplot</code></a></li><li><a href="#ControlSystemIdentification.detrend-Tuple{AbstractVector}"><code>ControlSystemIdentification.detrend</code></a></li><li><a href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="../ss/#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>ControlSystemIdentification.estimate_residuals</code></a></li><li><a href="#ControlSystemIdentification.estimate_x0"><code>ControlSystemIdentification.estimate_x0</code></a></li><li><a href="#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemIdentification.filter_bank</code></a></li><li><a href="#ControlSystemIdentification.find_na"><code>ControlSystemIdentification.find_na</code></a></li><li><a href="#ControlSystemIdentification.find_nanb"><code>ControlSystemIdentification.find_nanb</code></a></li><li><a href="#ControlSystemIdentification.find_similarity_transform"><code>ControlSystemIdentification.find_similarity_transform</code></a></li><li><a href="#ControlSystemIdentification.freqvec-Tuple{Any, AbstractVector}"><code>ControlSystemIdentification.freqvec</code></a></li><li><a href="#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector, AbstractVecOrMat, Any, Any}"><code>ControlSystemIdentification.getARXregressor</code></a></li><li><a href="../tf/#ControlSystemIdentification.getARXregressor"><code>ControlSystemIdentification.getARXregressor</code></a></li><li><a href="#ControlSystemIdentification.getARregressor-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.getARregressor</code></a></li><li><a href="../tf/#ControlSystemIdentification.getARregressor"><code>ControlSystemIdentification.getARregressor</code></a></li><li><a href="#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector}"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="#ControlSystemIdentification.iddata-Tuple{ControlSystemsBase.SimResult}"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="../iddata/#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.impulseest</code></a></li><li><a href="#ControlSystemIdentification.impulseestplot"><code>ControlSystemIdentification.impulseestplot</code></a></li><li><a href="#ControlSystemIdentification.kautz-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.kautz</code></a></li><li><a href="#ControlSystemIdentification.laguerre-Tuple{Any, Any}"><code>ControlSystemIdentification.laguerre</code></a></li><li><a href="#ControlSystemIdentification.laguerre_id-Tuple{Any, Any, Any}"><code>ControlSystemIdentification.laguerre_id</code></a></li><li><a href="../freq/#ControlSystemIdentification.laguerre_oo"><code>ControlSystemIdentification.laguerre_oo</code></a></li><li><a href="#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}"><code>ControlSystemIdentification.laguerre_oo</code></a></li><li><a href="#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous}}"><code>ControlSystemIdentification.minimum_phase</code></a></li><li><a href="../freq/#ControlSystemIdentification.model_spectrum"><code>ControlSystemIdentification.model_spectrum</code></a></li><li><a href="#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any}}"><code>ControlSystemIdentification.model_spectrum</code></a></li><li><a href="../ss/#ControlSystemIdentification.n4sid"><code>ControlSystemIdentification.n4sid</code></a></li><li><a href="#ControlSystemIdentification.n4sid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.n4sid</code></a></li><li><a href="../ss/#ControlSystemIdentification.newpem"><code>ControlSystemIdentification.newpem</code></a></li><li><a href="#ControlSystemIdentification.newpem-Union{Tuple{RE}, Tuple{F}, Tuple{Any, Any}} where {F, RE}"><code>ControlSystemIdentification.newpem</code></a></li><li><a href="#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}"><code>ControlSystemIdentification.noise_model</code></a></li><li><a href="#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a></li><li><a href="../ss/#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a></li><li><a href="#ControlSystemIdentification.pem-Tuple{Any}"><code>ControlSystemIdentification.pem</code></a></li><li><a href="../tf/#ControlSystemIdentification.plr"><code>ControlSystemIdentification.plr</code></a></li><li><a href="#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}"><code>ControlSystemIdentification.plr</code></a></li><li><a href="#ControlSystemIdentification.prediction_error-Tuple{AbstractStateSpace, ControlSystemIdentification.AbstractIdData, Vararg{Any}}"><code>ControlSystemIdentification.prediction_error</code></a></li><li><a href="../iddata/#ControlSystemIdentification.predictiondata"><code>ControlSystemIdentification.predictiondata</code></a></li><li><a href="#ControlSystemIdentification.predplot"><code>ControlSystemIdentification.predplot</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{Any, InputOutputData}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="#ControlSystemIdentification.ramp_in-Tuple{InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_in</code></a></li><li><a href="#ControlSystemIdentification.ramp_out-Tuple{InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_out</code></a></li><li><a href="#ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemIdentification.schur_stab</code></a></li><li><a href="#ControlSystemIdentification.simplot"><code>ControlSystemIdentification.simplot</code></a></li><li><a href="#ControlSystemIdentification.specplot"><code>ControlSystemIdentification.specplot</code></a></li><li><a href="#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputFreqData, Real}, Tuple{InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="../ss/#ControlSystemIdentification.subspaceid"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any}}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="../freq/#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.welchplot"><code>ControlSystemIdentification.welchplot</code></a></li><li><a href="#ControlSystemIdentification.wtls_estimator"><code>ControlSystemIdentification.wtls_estimator</code></a></li><li><a href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a></li><li><a href="#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>DSP.Filters.resample</code></a></li><li><a href="#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, Real}"><code>DSP.Filters.resample</code></a></li><li><a href="#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, Real}"><code>DSP.Filters.resample</code></a></li><li><a href="#DelimitedFiles.writedlm"><code>DelimitedFiles.writedlm</code></a></li><li><a href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="../validation/#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="#StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any}}"><code>StatsAPI.predict</code></a></li><li><a href="../validation/#StatsAPI.predict"><code>StatsAPI.predict</code></a></li><li><a href="#StatsAPI.predict-Tuple{TransferFunction, Any}"><code>StatsAPI.predict</code></a></li><li><a href="#StatsAPI.predict-Tuple{TransferFunction, InputOutputData}"><code>StatsAPI.predict</code></a></li><li><a href="#StatsAPI.residuals-Tuple{TransferFunction, InputOutputData}"><code>StatsAPI.residuals</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.FRD" href="#ControlSystemIdentification.FRD"><code>ControlSystemIdentification.FRD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FRD(w, r)</code></pre><p>Represents frequency-response data. <code>w</code> holds the frequency vector and <code>r</code> the response. Methods defined on this type include</p><ul><li><code>+-*</code></li><li><code>length, vec, sqrt</code></li><li><code>plot</code></li><li><a href="@ref"><code>feedback</code></a></li><li><a href="#ControlSystemIdentification.freqvec-Tuple{Any, AbstractVector}"><code>freqvec</code></a></li><li><a href="../freq/#ControlSystemIdentification.tfest"><code>tfest</code></a> to estimate a rational model</li><li>Indexing in the frequency domain using, e.g., <code>G[1Hz : 5Hz]</code>, <code>G[1rad : 5rad]</code></li></ul><p>If <code>r</code> represents a MIMO frequency response, the dimensions are <code>ny × nu × nω</code>.</p><p>An object <code>frd::FRD</code> can be plotted using <code>plot(frd, hz=false)</code> if <code>using Plots</code> has been called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.FRD-Tuple{Any, LTISystem}" href="#ControlSystemIdentification.FRD-Tuple{Any, LTISystem}"><code>ControlSystemIdentification.FRD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FRD(w, sys::LTISystem)</code></pre><p>Generate a frequency-response data object by evaluating the frequency response of <code>sys</code> at frequencies <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.Hz" href="#ControlSystemIdentification.Hz"><code>ControlSystemIdentification.Hz</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents frequencies in Herz for indexing of <code>FRD</code> objects: <code>frd[2Hz:10Hz]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.InputOutputData" href="#ControlSystemIdentification.InputOutputData"><code>ControlSystemIdentification.InputOutputData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>See <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.InputOutputFreqData" href="#ControlSystemIdentification.InputOutputFreqData"><code>ControlSystemIdentification.InputOutputFreqData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>See <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.N4SIDStateSpace" href="#ControlSystemIdentification.N4SIDStateSpace"><code>ControlSystemIdentification.N4SIDStateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">N4SIDStateSpace &lt;: AbstractPredictionStateSpace</code></pre><p>The result of statespace model estimation using the <code>n4sid</code> method.</p><p><strong>Fields:</strong></p><ul><li><code>sys</code>: estimated model in the form of a <a href="@ref"><code>StateSpace</code></a> object</li><li><code>Q</code>: estimated covariance matrix of the states</li><li><code>R</code>: estimated covariance matrix of the measurements</li><li><code>S</code>: estimated cross covariance matrix between states and measurements</li><li><code>K</code>: kalman observer gain</li><li><code>P</code>: solution to the Riccatti equation</li><li><code>x</code>: estimated state trajectory</li><li><code>s</code>: singular values</li><li><code>fve</code>: Fraction of variance explained by singular values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L422-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.PredictionStateSpace" href="#ControlSystemIdentification.PredictionStateSpace"><code>ControlSystemIdentification.PredictionStateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PredictionStateSpace{T, ST &lt;: AbstractStateSpace{T}, KT, QT, RT, ST2} &lt;: AbstractPredictionStateSpace{T}
PredictionStateSpace(sys, K, Q=nothing, R=nothing, S=nothing)</code></pre><p>A statespace type that contains an additional Kalman-filter model for prediction purposes.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: DESCRIPTION</li><li><code>K</code>: Infinite-horizon Kalman gain</li><li><code>Q = nothing</code>: Dynamics covariance</li><li><code>R = nothing</code>: Measurement covariance</li><li><code>S = nothing</code>: Cross-covariance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L393-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.rad" href="#ControlSystemIdentification.rad"><code>ControlSystemIdentification.rad</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents frequencies in rad/s for indexing of <code>FRD</code> objects: <code>frd[2rad:10rad]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.apply_fun" href="#ControlSystemIdentification.apply_fun"><code>ControlSystemIdentification.apply_fun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_fun(fun, d::InputOutputData)</code></pre><p>Apply <code>fun(y)</code> to all time series <code>y[,u,[x]] ∈ d</code> and return a new <code>iddata</code> with the transformed series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}" href="#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.ar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ar(d::AbstractIdData, na; λ=0, estimator=\, scaleB=false, stochastic=false)</code></pre><p>Estimate an AR transfer function <code>G = 1/A</code>, the AR process is defined as <code>A(z⁻¹)y(t) = e(t)</code></p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: IdData, see <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>na</code>: order of the model</li><li><code>λ</code>: <code>λ &gt; 0</code> can be provided for L₂ regularization</li><li><code>estimator</code>: e.g. <code>\,tls,irls,rtls</code></li><li><code>scaleB</code>: Whether or not to scale the numerator using the variance of the prediction error.</li><li><code>stochastic</code>: if true, returns a transfer function with uncertain parameters represented by <code>MonteCarloMeasurements.Particles</code>.</li></ul><p>Estimation of AR models using least-squares is known to struggle with heavy measurement noise, using <code>estimator = tls</code> can improve the result in this case.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; N = 10000
10000

julia&gt; e = [-0.2; zeros(N-1)] # noise e
10000-element Vector{Float64}:
[...]

julia&gt; G = tf([1, 0], [1, -0.9], 1) # AR transfer function
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
   1.0z
----------
1.0z - 0.9

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; y = lsim(G, e, 1:N)[1][:] # Get output of AR transfer function from input noise e
10000-element Vector{Float64}:
[...]

julia&gt; Gest = ar(iddata(y), 1) # Estimate AR transfer function from output y
TransferFunction{Discrete{Float64}, ControlSystemsBase.SisoRational{Float64}}
          1.0z
-------------------------
1.0z - 0.8999999999999998

Sample Time: 1.0 (seconds)
Discrete-time transfer function model

julia&gt; G ≈ Gest # Test if estimation was correct
true

julia&gt; eest = lsim(1/Gest, y, 1:N)[1][:] # recover the input noise e from output y and estimated transfer function Gest
10000-element Vector{Float64}:
[...]

julia&gt; isapprox(eest, e, atol = eps()) # input noise correct recovered
true </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L222-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}" href="#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model = arma(d::AbstractIdData, na, nc; initial_order=20, method=:ls)</code></pre><p>Estimate a Autoregressive Moving Average model with <code>na</code> coefficients in the denominator and <code>nc</code> coefficients in the numerator. Returns the model and the estimated noise sequence driving the system.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: iddata</li><li><code>initial_order</code>: An initial AR model of this order is used to estimate the residuals</li><li><code>estimator</code>: A function <code>(A,y)-&gt;minimizeₓ(Ax-y)</code> default is <code>\</code> but another option is <code>wtls_estimator(1:length(y)-initial_order,na,nc,ones(nc))</code></li></ul><p>See also <a href="#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>estimate_residuals</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L578-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}" href="#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma_ssa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arma_ssa(d::AbstractIdData, na, nc; L=nothing, estimator=\, robust=false)</code></pre><p>Fit arma models using Singular Spectrum Analysis (SSA). A low-rank factorization (svd or robust svd) is performed on the data in order to decompose the signal and the noise. The noise is then used as input to fit an arma model.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>:  iddata</li><li><code>na</code>: number of denominator parameters</li><li><code>nc</code>: number of numerator parameters</li><li><code>L</code>:  length of the lag-embedding used to separate signal and noise. <code>nothing</code> corresponds to automatic selection.</li><li><code>estimator</code>: The function to solve the least squares problem. Examples <code>\,tls,irls,rtls</code>.</li><li><code>robust</code>: Use robust PCA to be resistant to outliers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L825-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}" href="#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gtf = arx(d::AbstractIdData, na, nb; inputdelay = ones(Int, size(nb)), λ = 0, estimator=\, stochastic=false)</code></pre><p>Fit a transfer Function to data using an ARX model and equation error minimization.</p><ul><li><code>nb</code> and <code>na</code> are the number of coefficients of the numerator and denominator polynomials.</li></ul><p>Input delay can be added via <code>inputdelay = d</code>, which corresponds to an additional delay of <code>z^-d</code>. An <code>inputdelay = 0</code> results in a direct term. The highest order of the B polynomial is given by <code>nb + inputdelay - 1</code>.  <code>λ &gt; 0</code> can be provided for L₂ regularization. <code>estimator</code> defaults to \ (least squares), alternatives are <code>estimator = tls</code> for total least-squares estimation.  <code>arx(Δt,yn,u,na,nb, estimator=wtls_estimator(y,na,nb)</code> is potentially more robust in the presence of heavy measurement noise. The number of free parameters is <code>na+nb</code> </p><ul><li><code>stochastic</code>: if true, returns a transfer function with uncertain parameters represented by <code>MonteCarloMeasurements.Particles</code>.</li></ul><p>Supports MISO estimation by supplying an iddata with a matrix <code>u</code>, with nb = [nb₁, nb₂...] and optional inputdelay = [d₁, d₂...]</p><p>This function supports multiple datasets, provided as a vector of iddata objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L71-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arxar-Tuple{InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}" href="#ControlSystemIdentification.arxar-Tuple{InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}"><code>ControlSystemIdentification.arxar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G, H, e = arxar(d::InputOutputData, na::Int, nb::Union{Int, Vector{Int}}, nd::Int)</code></pre><p>Estimate the ARXAR model <code>Ay = Bu + v</code>, where <code>v = He</code> and <code>H = 1/D</code>, using generalized least-squares method. For more information see Söderström - Convergence properties of the generalized least squares identification method, 1974. </p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: iddata</li><li><code>na</code>: order of A</li><li><code>nb</code>: number of coefficients in B, the order is determined by <code>nb + inputdelay - 1</code>. In MISO estimation it takes the form <code>nb = [nb₁, nb₂...]</code>. </li><li><code>nd</code>: order of D</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>H = nothing</code>: prior knowledge about the AR noise model</li><li><code>inputdelay = ones(Int, size(nb))</code>: optional delay of input, inputdelay = 0 results in a direct term, takes the form inputdelay = [d₁, d₂...] in MISO estimation </li><li><code>λ = 0</code>: <code>λ &gt; 0</code> can be provided for L₂ regularization</li><li><code>estimator = \</code>: e.g. <code>\,tls,irls,rtls</code>, the latter three require <code>using TotalLeastSquares</code></li><li><code>δmin = 10e-4</code>: Minimal change in the power of e, that specifies convergence.</li><li><code>iterations = 10</code>: maximum number of iterations.</li><li><code>verbose = false</code>: if true, more information is printed</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; N = 500 
500

julia&gt; sim(G, u) = lsim(G, u, 1:N)[1][:]
sim (generic function with 1 method)

julia&gt; A = tf([1, -0.8], [1, 0], 1)
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
1.0z - 0.8
----------
   1.0z

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; B = tf([0, 1], [1, 0], 1)
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Int64}}
1
-
z

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; G = minreal(B / A)
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
   1.0
----------
1.0z - 0.8

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; D = tf([1, 0.7], [1, 0], 1)
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
1.0z + 0.7
----------
   1.0z

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; H = 1 / D
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
   1.0z
----------
1.0z + 0.7

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; u, e = randn(1, N), randn(1, N)
[...]

julia&gt; y, v = sim(G, u), sim(H * (1/A), e) # simulate process
[...]

julia&gt; d = iddata(y .+ v, u, 1)
InputOutput data of length 500 with 1 outputs and 1 inputs

julia&gt; na, nb , nd = 1, 1, 1
(1, 1, 1)

julia&gt; Gest, Hest, res = arxar(d, na, nb, nd)
(G = TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
   0.9987917259291642
-------------------------
1.0z - 0.7937837464682017

Sample Time: 1 (seconds)
Discrete-time transfer function model, H = TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Float64}}
          1.0z
-------------------------
1.0z + 0.7019519225937721

Sample Time: 1 (seconds)
Discrete-time transfer function model, e = [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L297-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.autocorplot" href="#ControlSystemIdentification.autocorplot"><code>ControlSystemIdentification.autocorplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">autocorplot(y, Ts, [lags])</code></pre><p>Plot the auto correlation of <code>y</code> for <code>lags</code> that default to <code>1:size(y, 2)÷2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.coherence-Tuple{ControlSystemIdentification.AbstractIdData}" href="#ControlSystemIdentification.coherence-Tuple{ControlSystemIdentification.AbstractIdData}"><code>ControlSystemIdentification.coherence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">κ = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming)</code></pre><p>Calculates the magnitude-squared coherence Function. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ &lt;&lt; 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy.</p><ul><li>κ: Coherence function (not squared) in the form of an <a href="../api/#ControlSystemIdentification.FRD"><code>FRD</code></a>.</li></ul><p>See also <a href="../api/#ControlSystemIdentification.coherenceplot"><code>coherenceplot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L202-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.coherenceplot" href="#ControlSystemIdentification.coherenceplot"><code>ControlSystemIdentification.coherenceplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coherenceplot(d, [(;n=..., noverlap=...); hz=false)</code></pre><p>Calculates and plots the (squared) coherence Function κ. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ &lt;&lt; 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy.</p><p><code>hz</code> indicates Hertz instead of rad/s</p><p>Keyword arguments to <code>coherence</code> are supplied as a named tuple as a second positional argument .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L247-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.crosscorplot" href="#ControlSystemIdentification.crosscorplot"><code>ControlSystemIdentification.crosscorplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crosscorplot(data, [lags])
crosscorplot(u, y, Ts, [lags])</code></pre><p>Plot the cross correlation between input and output for <code>lags</code> that default to 10% of the length of the dataset on the negative side and 50% on the positive side but no more than 100 on each side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L341-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.detrend-Tuple{AbstractVector}" href="#ControlSystemIdentification.detrend-Tuple{AbstractVector}"><code>ControlSystemIdentification.detrend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detrend(d::AbstractArray)
detrend(d::AbstractIdData)</code></pre><p>Remove the mean from <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L312-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.era" href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">era(d::AbstractIdData, nx; m = 2nx, n = 2nx, l = 5nx, p = l, λ=0)
era(ds::Vector{IdData}, nx; m = 2nx, n = 2nx, l = 5nx, p = l, λ=0)</code></pre><p>Eigenvalue realization algorithm. Uses <code>okid</code> to find the Markov parameters as an initial step.</p><p>The parameter <code>l</code> is likely to require tuning, a reasonable starting point to choose <code>l</code> large enough for the impulse response to have mostly dissipated.</p><p>If a vector of datasets is provided, the Markov parameters estimated from each experiment are averaged before calling <code>era</code>. This allows use of data from multiple experiments to improve the model estimate.</p><p><strong>Arguments:</strong></p><ul><li><code>nx</code>: Model order</li><li><code>l</code>: Number of Markov parameters to estimate.</li><li><code>λ</code>: Regularization parameter (don&#39;t overuse this, prefer to make more experiments instead)</li><li><code>p</code>: Optionally, delete the first <code>p</code> columns in the internal Hankel matrices to account for initial conditions != 0. If <code>x0 != 0</code>, for <code>era</code>, <code>p</code> defaults to <code>l</code>, while when calling <code>okid</code> directly, <code>p</code> defaults to 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace.jl#L348-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.era" href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">era(YY::AbstractArray{&lt;:Any, 3}, Ts, nx::Int, m::Int = 2nx, n::Int = 2nx)</code></pre><p>Eigenvalue realization algorithm. The algorithm returns a statespace model.</p><p><strong>Arguments:</strong></p><ul><li><code>YY</code>: Markov parameters (impulse response) size <code>ny × nu × n_time</code></li><li><code>Ts</code>: Sample time</li><li><code>nx</code>: Model order</li><li><code>m</code>: Number of rows in Hankel matrix</li><li><code>n</code>: Number of columns in Hankel matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace.jl#L299-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}" href="#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>ControlSystemIdentification.estimate_residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_residuals(model, y)</code></pre><p>Estimate the residuals driving the dynamics of an ARMA model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L863-L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.estimate_x0" href="#ControlSystemIdentification.estimate_x0"><code>ControlSystemIdentification.estimate_x0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_x0(sys, d, n = min(length(d), 3 * slowest_time_constant(sys)); fixed = fill(NaN, sys.nx)</code></pre><p>Estimate the initial state of the system </p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>n</code>: Number of samples to use.</li><li><code>fixed</code>: If a vector of the same length as <code>x0</code> is provided, finite values indicate fixed values that are not to be estimated, while nonfinite values are free.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sys   = ssrand(2,3,4, Ts=1)
x0    = randn(sys.nx)
u     = randn(sys.nu, 100)
y,t,x = lsim(sys, u; x0)
d     = iddata(y, u, 1)
x0h   = estimate_x0(sys, d, 8, fixed=[Inf, x0[2], Inf, Inf])
x0h[2] == x0[2] # Should be exact equality
norm(x0-x0h)    # Should be small</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L135-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}" href="#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemIdentification.filter_bank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_bank(basis::AbstractStateSpace{&lt;:Discrete}, signal::AbstractMatrix)</code></pre><p>Filter <code>signal</code> through all systems in <code>basis</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/basis_functions.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.find_na" href="#ControlSystemIdentification.find_na"><code>ControlSystemIdentification.find_na</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_na(y::AbstractVector,n::Int)</code></pre><p>Plots the RMSE and AIC For model orders up to <code>n</code>. Useful for model selection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L461-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.find_nanb" href="#ControlSystemIdentification.find_nanb"><code>ControlSystemIdentification.find_nanb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_nanb(d::InputOutputData,na,nb)</code></pre><p>Plots the RMSE and AIC For model orders up to <code>n</code>. Useful for model selection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L486-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.find_similarity_transform" href="#ControlSystemIdentification.find_similarity_transform"><code>ControlSystemIdentification.find_similarity_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_similarity_transform(sys1, sys2)</code></pre><p>Find T such that <code>ControlSystemsBase.similarity_transform(sys1, T) == sys2</code></p><p>Ref: Minimal state-space realization in linear system theory: an overview, B. De Schutter</p><pre><code class="language-julia-repl hljs">julia&gt; T = randn(3,3);

julia&gt; sys1 = ssrand(1,1,3);

julia&gt; sys2 = ControlSystemsBase.similarity_transform(sys1, T);

julia&gt; T2 = find_similarity_transform(sys1, sys2);

julia&gt; T2 ≈ T
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace2.jl#L635-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.freqvec-Tuple{Any, AbstractVector}" href="#ControlSystemIdentification.freqvec-Tuple{Any, AbstractVector}"><code>ControlSystemIdentification.freqvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freqvec(h, k)</code></pre><p>Return a frequency vector of length <code>k</code> for systems with sample time <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.getARXregressor-Tuple{AbstractVector, AbstractVecOrMat, Any, Any}" href="#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector, AbstractVecOrMat, Any, Any}"><code>ControlSystemIdentification.getARXregressor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb; inputdelay = ones(Int, size(nb)))</code></pre><p>Returns a shortened output signal <code>y</code> and a regressor matrix <code>A</code> such that the least-squares ARX model estimate of order <code>na,nb</code> is <code>y\A</code></p><p>Return a regressor matrix used to fit an ARX model on, e.g., the form <code>A(z)y = B(z)u</code> with output <code>y</code> and input <code>u</code> where the order of autoregression is <code>na</code>, the order of input moving average is <code>nb</code> and an optional input delay <code>inputdelay</code>. Caution, changing the input delay changes the order to <code>nb + inputdelay - 1</code>. An <code>inputdelay = 0</code> results in a direct term. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A     = [1,2*0.7*1,1] # A(z) coeffs
B     = [10,5] # B(z) coeffs
u     = randn(100) # Simulate 100 time steps with Gaussian input
y     = filt(B,A,u)
yr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2
x     = A\yr # Estimate model polynomials
plot([yr A*x], lab=[&quot;Signal&quot; &quot;Prediction&quot;])</code></pre><p>For nonlinear ARX-models, see <a href="https://github.com/baggepinnen/BasisFunctionExpansions.jl/">BasisFunctionExpansions.jl</a>. See also <code>arx</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.getARregressor-Tuple{AbstractVector, Any}" href="#ControlSystemIdentification.getARregressor-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.getARregressor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yt,A = getARregressor(y::AbstractVector, na)</code></pre><p>Returns values such that <code>x = A\yt</code>. See <a href="../tf/#ControlSystemIdentification.getARXregressor"><code>getARXregressor</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.iddata" href="#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iddata(y,       Ts = nothing)
iddata(y, u,    Ts = nothing)
iddata(y, u, x, Ts = nothing)</code></pre><p>Create a <strong>time-domain</strong> identification data object. </p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractArray</code>: output data (required)</li><li><code>u::AbstractArray</code>: input data (if available)</li><li><code>x::AbstractArray</code>: state data (if available)</li><li><code>Ts::Union{Real,Nothing} = nothing</code>: optional sample time</li></ul><p>If the time-series are multivariate, time is in the <em>last</em> dimension, i.e., the sizes of the arrays are <code>(num_variables, num_timepoints)</code> (see examples below).</p><p><strong>Operations on iddata</strong></p><ul><li><a href="#ControlSystemIdentification.detrend-Tuple{AbstractVector}"><code>detrend</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{Any, InputOutputData}"><code>prefilter</code></a></li><li><a href="#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, Real}"><code>resample</code></a></li><li>append two along the time dimension <code>[d1 d2]</code></li><li>index time series <code>d[output_index, input_index]</code></li><li>index the time axis with indices <code>d[time_indices]</code></li><li>index the time axis with seconds <code>d[3Sec:12Sec]</code> (<code>using ControlSystemIdentification: Sec</code>)</li><li>access number of inputs, outputs and sample time: <code>d.nu, d.ny, d.Ts</code></li><li>access the time time vector <code>d.t</code></li><li>premultiply to scale outputs <code>C * d</code>. Scaling the outputs of a multiple-output system to have roughly the same size is usually recommended before estimating a model in case they have different magnitudes.</li><li>postmultiply to scale inputs <code>d * B</code></li><li><a href="#DelimitedFiles.writedlm"><code>writedlm</code></a></li><li><a href="#ControlSystemIdentification.ramp_in-Tuple{InputOutputData, Int64}"><code>ramp_in</code></a>, <a href="#ControlSystemIdentification.ramp_out-Tuple{InputOutputData, Int64}"><code>ramp_out</code></a></li><li><code>plot</code></li><li><a href="#ControlSystemIdentification.specplot"><code>specplot</code></a></li><li><a href="#ControlSystemIdentification.crosscorplot"><code>crosscorplot</code></a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iddata(randn(10))
Output data of length 10 with 1 outputs, Ts = nothing

julia&gt; iddata(randn(10), randn(10), 1)
InputOutput data of length 10, 1 outputs, 1 inputs, Ts = 1

julia&gt; d = iddata(randn(2, 10), randn(3, 10), 0.1)
InputOutput data of length 10, 2 outputs, 3 inputs, Ts = 0.1

julia&gt; [d d] # Concatenate along time
InputOutput data of length 20, 2 outputs, 3 inputs, Ts = 0.1

julia&gt; d[1:3]
InputOutput data of length 3, 2 outputs, 3 inputs, Ts = 0.1

julia&gt; d.nu
3

julia&gt; d.t # access time vector
0.0:0.1:0.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L75-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector}" href="#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector}"><code>ControlSystemIdentification.iddata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iddata(y::AbstractArray, u::AbstractArray, w::AbstractVector)</code></pre><p>Create a <strong>frequency-domain</strong> input-output data object. <code>w</code> is expected to be in rad/s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.iddata-Tuple{ControlSystemsBase.SimResult}" href="#ControlSystemIdentification.iddata-Tuple{ControlSystemsBase.SimResult}"><code>ControlSystemIdentification.iddata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iddata(res::ControlSystemsBase.SimResult)</code></pre><p>Create an identification-data object directly from a simulation result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}" href="#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.impulseest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ir, t, Σ = impulseest(d::AbstractIdData, n; λ=0, estimator=ls)</code></pre><p>Estimates the system impulse response by fitting an <code>n</code>:th order FIR model. Returns impulse-response estimate, time vector and covariance matrix. See also <a href="#ControlSystemIdentification.impulseestplot"><code>impulseestplot</code></a> and <a href="../ss/#ControlSystemIdentification.okid"><code>okid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.impulseestplot" href="#ControlSystemIdentification.impulseestplot"><code>ControlSystemIdentification.impulseestplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">impulseestplot(data,n; σ = 2)</code></pre><p>Estimates the system impulse response by fitting an <code>n</code>:th order FIR model and plots the result with a 95% (2σ) confidence band. See also <a href="#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>impulseest</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L291-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.kautz-Tuple{AbstractVector, Any}" href="#ControlSystemIdentification.kautz-Tuple{AbstractVector, Any}"><code>ControlSystemIdentification.kautz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kautz(a::Vector, h)</code></pre><p>Construct a discrete-time Kautz basis with poles at <code>a</code> amd sample time <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/basis_functions.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.laguerre-Tuple{Any, Any}" href="#ControlSystemIdentification.laguerre-Tuple{Any, Any}"><code>ControlSystemIdentification.laguerre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laguerre(a::Number, Nq)</code></pre><p>Construct a Laguerre basis of length <code>Nq</code> with poles at <code>-a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/basis_functions.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.laguerre_id-Tuple{Any, Any, Any}" href="#ControlSystemIdentification.laguerre_id-Tuple{Any, Any, Any}"><code>ControlSystemIdentification.laguerre_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laguerre_id(a::Number, Nq, Ts)</code></pre><p>Construct a discrete-time Laguerre basis of length <code>Nq</code> with poles at <code>-a</code> for system identification.</p><p>NOTE: for large <code>Nq</code>, this basis may be numerically ill-conditioned. Consider applying <code>balance_statespace</code> to the resulting basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/basis_functions.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}" href="#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}"><code>ControlSystemIdentification.laguerre_oo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laguerre_oo(a::Number, Nq)</code></pre><p>Construct an output orthogonalized Laguerre basis of length <code>Nq</code> with poles at <code>-a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/basis_functions.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous}}" href="#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous}}"><code>ControlSystemIdentification.minimum_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum_phase(G)</code></pre><p>Move zeros and poles of <code>G</code> from the unstable half plane to the stable. If <code>G</code> is a statespace system, it&#39;s converted to a transfer function first. This can incur loss of precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/basis_functions.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any}}" href="#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any}}"><code>ControlSystemIdentification.model_spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_spectrum(f, h, args...; kwargs...)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>f</code>: the model-estimation function, e.g., <code>ar,arma</code></li><li><code>h</code>: The sample time</li><li><code>args</code>: arguments to <code>f</code></li><li><code>kwargs</code>: keyword arguments to <code>f</code></li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">using ControlSystemIdentification, DSP
T = 1000
s = sin.((1:T) .* 2pi/10)
S1 = spectrogram(s,window=hanning)
estimator = model_spectrum(ar,1,2)
S2 = spectrogram(s,estimator,window=rect)
plot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/spectrogram.jl#L93-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.n4sid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}" href="#ControlSystemIdentification.n4sid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.n4sid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">res = n4sid(data, r=:auto; verbose=false)</code></pre><p>Estimate a statespace model using the n4sid method. Returns an object of type <a href="#ControlSystemIdentification.N4SIDStateSpace"><code>N4SIDStateSpace</code></a> where the model is accessed as <code>res.sys</code>.</p><p>Implements the simplified algorithm (alg 2) from &quot;N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems&quot; PETER VAN OVERSCHEE and BART DE MOOR</p><p>The frequency weighting is borrowing ideas from &quot;Frequency Weighted Subspace Based System Identification in the Frequency Domain&quot;, Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Identification data <code>data = iddata(y,u)</code></li><li><code>r</code>: Rank of the model (model order)</li><li><code>verbose</code>: Print stuff?</li><li><code>Wf</code>: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like <code>Wf = Bandstop(lower, upper, fs=1/Ts)</code> to indicate that there are disturbances <em>outside</em> this band.</li><li><code>i</code>: Algorithm parameter, generally no need to tune this</li><li><code>γ</code>: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.</li><li><code>zeroD</code>: defaults to false</li></ul><p>See also the newer implementation <a href="../ss/#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> which allows you to choose between different weightings (n4sid being one of them). A more accurate prediciton model can sometimes be obtained using <a href="../ss/#ControlSystemIdentification.newpem"><code>newpem</code></a>, which is also unbiased for closed-loop data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace.jl#L5-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.newpem-Union{Tuple{RE}, Tuple{F}, Tuple{Any, Any}} where {F, RE}" href="#ControlSystemIdentification.newpem-Union{Tuple{RE}, Tuple{F}, Tuple{Any, Any}} where {F, RE}"><code>ControlSystemIdentification.newpem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sys, x0, res = newpem(
    d,
    nx;
    zeroD  = true,
    focus  = :prediction,
    stable = true,
    sys0   = subspaceid(d, nx; zeroD, focus, stable),
    metric = abs2,
    regularizer = (p, P) -&gt; 0,
    optimizer = BFGS(
        linesearch = LineSearches.BackTracking(),
    ),
    store_trace = true,
    show_trace  = true,
    show_every  = 50,
    iterations  = 10000,
    time_limit  = 100,
    x_tol       = 0,
    f_abstol    = 0,
    g_tol       = 1e-12,
    f_calls_limit = 0,
    g_calls_limit = 0,
    allow_f_increases = false,
)</code></pre><p>A new implementation of the prediction-error method (PEM). Note that this is an experimental implementation and subject to breaking changes not respecting semver.</p><p>The prediction-error method is an iterative, gradient-based optimization problem, as such, it can be extra sensitive to signal scaling, and it&#39;s recommended to perform scaling to <code>d</code> before estimation, e.g., by pre and post-multiplying with diagonal matrices <code>d̃ = Dy*d*Du</code>, and apply the inverse scaling to the resulting system. In this case, we have</p><p class="math-container">\[D_y y = G̃ D_u u ↔ y = D_y^{-1} G̃ D_u u\]</p><p>hence <code>G = Dy \ G̃ * Du</code> where $ G̃ $ is the plant estimated for the scaled iddata. Example:</p><pre><code class="language-julia hljs">Dy = Diagonal(1 ./ vec(std(d.y, dims=2))) # Normalize variance
Du = Diagonal(1 ./ vec(std(d.u, dims=2))) # Normalize variance
d̃ = Dy * d * Du</code></pre><p>If a manually provided initial guess <code>sys0</code>, this must also be scaled appropriately.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>nx</code>: Model order</li><li><code>zeroD</code>: Force zero <code>D</code> matrix</li><li><code>stable</code> if true, stability of the estimated system will be enforced by eigenvalue reflection using <a href="#ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>schur_stab</code></a> with <code>ϵ=1/100</code> (default). If <code>stable</code> is a real value, the value is used instead of the default <code>ϵ</code>.</li><li><code>sys0</code>: Initial guess, if non provided, <a href="../ss/#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> is used as initial guess.</li><li><code>focus</code>: <code>prediction</code> or <code>:simulation</code>. If <code>:simulation</code>, the <code>K</code> matrix will be zero.</li><li><code>optimizer</code>: One of Optim&#39;s optimizers</li><li><code>metric</code>: The metric used to measure residuals. Try, e.g., <code>abs</code> for better resistance to outliers.</li></ul><p>The rest of the arguments are related to <code>Optim.Options</code>.</p><ul><li><code>regularizer</code>: A function of the parameter vector and the corresponding <code>PredictionStateSpace/StateSpace</code> system that can be used to regularize the estimate.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using ControlSystemIdentification, ControlSystemsBase Plots
G = DemoSystems.doylesat()
T = 1000  # Number of time steps
Ts = 0.01 # Sample time
sys = c2d(G, Ts)
nx = sys.nx
nu = sys.nu
ny = sys.ny
x0 = zeros(nx) # actual initial state
sim(sys, u, x0 = x0) = lsim(sys, u; x0)[1]

σy = 1e-1 # Noise covariance

u  = randn(nu, T)
y  = sim(sys, u, x0)
yn = y .+ σy .* randn.() # Add measurement noise
d  = iddata(yn, u, Ts)

sysh, x0h, opt = ControlSystemIdentification.newpem(d, nx, show_every=10)

plot(
    bodeplot([sys, sysh]),
    predplot(sysh, d, x0h), # Include the estimated initial state in the prediction
)</code></pre><p>The returned model is of type <code>PredictionStateSpace</code> and contains the field <code>sys</code> with the system model, as well as covariance matrices and estimated Kalman gain for a Kalman filter.</p><p><strong>Extended help</strong></p><p>This implementation uses a tridiagonal parametrization of the A-matrix that has been shown to be favourable from an optimization perspective.¹ The initial guess <code>sys0</code> is automatically transformed to a special tridiagonal modal form.  [1]: Mckelvey, Tomas &amp; Helmersson, Anders. (1997). State-space parametrizations of multivariable linear systems using tridiagonal matrix forms.</p><p>The parameter vector used in the optimization takes the following form</p><pre><code class="language-julia hljs">p = [trivec(A); vec(B); vec(C); vec(D); vec(K); vec(x0)]</code></pre><p>Where <code>ControlSystemIdentification.trivec</code> vectorizes the <code>-1,0,1</code> diagonals of <code>A</code>. If <code>focus = :simulation</code>, <code>K</code> is omitted, and if <code>zeroD = true</code>, <code>D</code> is omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/pem.jl#L39-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}" href="#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}"><code>ControlSystemIdentification.noise_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noise_model(sys::AbstractPredictionStateSpace)</code></pre><p>Return a model of the noise driving the system, <code>v</code>, in</p><p class="math-container">\[x&#39; = Ax + Bu + Kv\\
y = Cx + Du + v\]</p><p>The model neglects u and is given by</p><p class="math-container">\[x&#39; = Ax + Kv\\
y = Cx + v\]</p><p>Also called the &quot;innovation form&quot;. This function calls <code>ControlSystemsBase.innovation_form</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L240-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.okid" href="#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)</code></pre><p>Observer Kalman filter identification. Returns the Markov parameters (impulse response) <code>H</code> size <code>ny × nu × (l+1)</code>.</p><p>The parameter <code>l</code> is likely to require tuning, a reasonable starting point to choose <code>l</code> large enough for the impulse response to have mostly dissipated.</p><p><strong>Arguments:</strong></p><ul><li><code>nx</code>: Model order</li><li><code>l</code>: Number of Markov parameters to estimate (length of impulse response).</li><li><code>λ</code>: Regularization parameter</li><li><code>p</code>: Optionally, delete the first <code>p</code> columns in the internal Hankel matrices to account for initial conditions != 0. If <code>x0 != 0</code>, try setting <code>p</code> around the same value as <code>l</code>.</li><li><code>estimator</code>: Function to use for estimating the Markov parameters. Defaults to <code>/</code> (least squares), but can also be a robust option such as <code>TotalLeastSquares.irls / flts</code> or <code>TotalLeastSquares.tls</code> for a total least-squares solutoins (errors in variables).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace.jl#L377-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.pem-Tuple{Any}" href="#ControlSystemIdentification.pem-Tuple{Any}"><code>ControlSystemIdentification.pem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function is deprecated, see <a href="../ss/#ControlSystemIdentification.newpem"><code>newpem</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/pem.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}" href="#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}"><code>ControlSystemIdentification.plr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G, Gn = plr(d::AbstractIdData,na,nb,nc; initial_order = 20)</code></pre><p>Perform pseudo-linear regression to estimate a model on the form <code>Ay = Bu + Cw</code> The residual sequence is estimated by first estimating a high-order arx model, whereafter the estimated residual sequence is included in a second estimation problem. The return values are the estimated system model, and the estimated noise model. <code>G</code> and <code>Gn</code> will always have the same denominator polynomial.</p><p><code>armax</code> is an alias for <code>plr</code>. See also <a href="#ControlSystemIdentification.pem-Tuple{Any}"><code>pem</code></a>, <a href="../tf/#ControlSystemIdentification.ar"><code>ar</code></a>, <a href="../tf/#ControlSystemIdentification.arx"><code>arx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L537-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prediction_error-Tuple{AbstractStateSpace, ControlSystemIdentification.AbstractIdData, Vararg{Any}}" href="#ControlSystemIdentification.prediction_error-Tuple{AbstractStateSpace, ControlSystemIdentification.AbstractIdData, Vararg{Any}}"><code>ControlSystemIdentification.prediction_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">e = prediction_error(sys::AbstractStateSpace, d::AbstractIdData, args...; kwargs...)</code></pre><p>Return the prediction errors `d.y - predict(sys, d, ...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.predplot" href="#ControlSystemIdentification.predplot"><code>ControlSystemIdentification.predplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predplot(sys, data, x0=nothing; ploty=true, plote=false, h=1, sysname=&quot;&quot;)</code></pre><p>Plot system simulation and measured output to compare them. <code>ploty</code> determines whether or not to plot the measured signal <code>plote</code> determines whether or not to plot the residual <code>h</code> is the prediction horizon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L162-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prefilter-Tuple{Any, InputOutputData}" href="#ControlSystemIdentification.prefilter-Tuple{Any, InputOutputData}"><code>ControlSystemIdentification.prefilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prefilter(f, d::InputOutputData)</code></pre><p>Apply filter coefficients to identification data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frequency_weights.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}" href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}"><code>ControlSystemIdentification.prefilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prefilter(d::AbstractIdData, responsetype::FilterType)</code></pre><p>Filter both input and output of the identification data using zero-phase filtering (<code>filtfilt</code>). Since both input and output is filtered, linear identification will not be affected in any other way than to focus the fit on the selected frequency range, i.e. the range that has high gain in the provided filter. Note, if the system that generated <code>d</code> is nonlinear, identification might be severely impacted by this transformation. Verify linearity with, e.g., <code>coherenceplot</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frequency_weights.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}" href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}"><code>ControlSystemIdentification.prefilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prefilter(d::AbstractIdData, l::Number, u::Number)</code></pre><p>Filter input and output with a bandpass filter between <code>l</code> and <code>u</code> Hz. If <code>l = 0</code> a lowpass filter will be used, and if <code>u = Inf</code> a highpass filter will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frequency_weights.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.ramp_in-Tuple{InputOutputData, Int64}" href="#ControlSystemIdentification.ramp_in-Tuple{InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ramp_in(d::InputOutputData, h::Int; rev = false)</code></pre><p>Multiply the initial <code>h</code> samples of input and output signals with a linearly increasing ramp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.ramp_out-Tuple{InputOutputData, Int64}" href="#ControlSystemIdentification.ramp_out-Tuple{InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_out</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ramp_out(d::InputOutputData, h::Int)</code></pre><p>Multiply the final <code>h</code> samples of input and output signals with a linearly decreasing  ramp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L370-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T" href="#ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemIdentification.schur_stab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">schur_stab(A::AbstractMatrix{T}, ϵ = 0.01)</code></pre><p>Stabilize the eigenvalues of discrete-time matrix <code>A</code> by transforming <code>A</code> to complex Schur form and projecting unstable eigenvalues 1-ϵ &lt; λ ≤ 2 into the unit disc. Eigenvalues &gt; 2 are set to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace2.jl#L564-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.simplot" href="#ControlSystemIdentification.simplot"><code>ControlSystemIdentification.simplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplot(sys, data, x0=nothing; ploty=true, plote=false, sysname=&quot;&quot;)</code></pre><p>Plot system simulation and measured output to compare them. <code>ploty</code> determines whether or not to plot the measured signal <code>plote</code> determines whether or not to plot the residual</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.specplot" href="#ControlSystemIdentification.specplot"><code>ControlSystemIdentification.specplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">specplot(d::IdData, args...; kwargs...)</code></pre><p>Plot a spectrogram of the input and output timeseries. See also <a href="#ControlSystemIdentification.welchplot"><code>welchplot</code></a>.</p><p>Additional arguments are passed along to <code>DSP.spectrogram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any}}" href="#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any}}"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model, x0 = subspaceid(frd::FRD, Ts, args...; estimate_x0 = false, bilinear_transform = false, kwargs...)</code></pre><p>If a frequency-reponse data object is supplied</p><ul><li>The FRD will be automatically converted to an <a href="#ControlSystemIdentification.InputOutputFreqData"><code>InputOutputFreqData</code></a></li><li><code>estimate_x0</code> is by default set to 0.</li><li><code>bilinear_transform</code> transform the frequency vector to discrete time, see note below.</li></ul><p>Note: if the frequency-response data comes from a frequency-response analysis, a bilinear transform of the data is required before estimation. This transform will be applied if <code>bilinear_transform = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace2.jl#L380-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}" href="#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subspaceid(
    data::InputOutputData,
    nx = :auto;
    verbose = false,
    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used
    s1 = r, # number of past outputs
    s2 = r, # number of past inputs
    W = :MOESP,
    zeroD = false,
    stable = true, 
    focus = :prediction,
    svd::F1 = svd!,
    scaleU = true,
    Aestimator::F2 = \,
    Bestimator::F3 = \,
    weights = nothing,
)</code></pre><p>Estimate a state-space model using subspace-based identification. Several different subspace-based algorithms are available, and can be chosen using the <code>W</code> keyword. Options are <code>:MOESP, :CVA, :N4SID, :IVM</code>.</p><p>Ref: Ljung, Theory for the user.</p><p>Resistance against outliers can be improved by supplying a custom factorization algorithm and replacing the internal least-squares estimators. See the documentation for the keyword arguments <code>svd</code>, <code>Aestimator</code>, and <code>Bestimator</code> below.</p><p>The returned model is of type <code>N4SIDStateSpace</code> and contains the field <code>sys</code> with the system model, as well as covariance matrices for a Kalman filter.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Identification data <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>nx</code>: Rank of the model (model order)</li><li><code>verbose</code>: Print stuff?</li><li><code>r</code>: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.</li><li><code>s1</code>: past horizon of outputs</li><li><code>s2</code>: past horizon of inputs</li><li><code>W</code>: Weight type, choose between <code>:MOESP, :CVA, :N4SID, :IVM</code></li><li><code>zeroD</code>: Force the <code>D</code> matrix to be zero.</li><li><code>stable</code>: Stabilize unstable system using eigenvalue reflection.</li><li><code>focus</code>: <code>:prediction</code> or <code>simulation</code></li><li><code>svd</code>: The function to use for <code>svd</code>. For resistance against outliers, consider using <code>TotalLeastSquares.rpca</code> to preprocess the data matrix before applying <code>svd</code>, like <code>svd = A-&gt;svd!(rpca(A)[1])</code>.</li><li><code>scaleU</code>: Rescale the input channels to have the same energy.</li><li><code>Aestimator</code>: Estimator function used to estimate <code>A,C</code>. The default is `<code>, i.e., least squares, but robust estimators, such as</code>irls, flts, rtls` from <a href="https://github.com/baggepinnen/TotalLeastSquares.jl/">TotalLeastSquares.jl</a>, can be used to gain resistance against outliers.</li><li><code>Bestimator</code>: Estimator function used to estimate <code>B,D</code>. Weighted estimation can be eachieved by passing <code>wls</code> from TotalLeastSquares.jl together with the <code>weights</code> keyword argument.</li><li><code>weights</code>: A vector of weights can be provided if the <code>Bestimator</code> is <code>wls</code>. </li></ul><p><strong>Extended help</strong></p><p>A more accurate prediciton model can sometimes be obtained using <a href="../ss/#ControlSystemIdentification.newpem"><code>newpem</code></a>, which is also unbiased for closed-loop data (<code>subspaceid</code> is biased for closed-loop data, see example in the docs). The prediction-error method is iterative and generally more expensive than <code>subspaceid</code>, and uses this function (by default) to form the initial guess for the optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace2.jl#L159-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputFreqData, Real}, Tuple{InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}" href="#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputFreqData, Real}, Tuple{InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model, x0 = subspaceid(data::InputOutputFreqData,
    Ts = data.Ts,
    nx = :auto;
    cont = false,
    verbose = false,
    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order
    zeroD = false,
    estimate_x0 = true,
    stable = true, 
    svd = svd!,
    Aestimator = \,
    Bestimator = \,
    weights = nothing
)</code></pre><p>Estimate a state-space model using subspace-based identification in the frequency domain.</p><p>If results are poor, try modifying <code>r</code>, in particular if the amount of data is low.</p><p>See the <a href="https://baggepinnen.github.io/ControlSystemIdentification.jl/dev/freq/#Statespace">docs</a> for an example.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: A frequency-domain identification data object.</li><li><code>Ts</code>: Sample time at which the data was collected</li><li><code>nx</code>: Desired model order, an interer or <code>:auto</code>.</li><li><code>cont</code>: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function <code>d2c</code>.</li><li><code>verbose</code>: Print stuff?</li><li><code>r</code>: Internal model order, must be ≥ <code>nx</code>.</li><li><code>zeroD</code>: Force the <code>D</code> matrix to be zero.</li><li><code>estimate_x0</code>: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.</li><li><code>stable</code>: For the model to be stable (uses <a href="#ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>schur_stab</code></a>).</li><li><code>svd</code>: The <code>svd</code> function to use.</li><li><code>Aestimator</code>: The estimator of the <code>A</code> matrix (and initial <code>C</code>-matrix).</li><li><code>Bestimator</code>: The estimator of B/D and C/D matrices.</li><li><code>weights</code>: An optional vector of frequency weights of the same length as the number of frequencies in `data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/subspace2.jl#L399-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.tfest" href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">H, N = tfest(data, σ = 0.05)</code></pre><p>Estimate a transfer function model using the Correlogram approach. Both <code>H</code> and <code>N</code> are of type <code>FRD</code> (frequency-response data).</p><ul><li><code>σ</code> determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger <code>σ</code> implies less smoothing.</li><li><code>H</code> = Syu/Suu             Process transfer function</li><li><code>N</code> = Sy - |Syu|²/Suu     Noise PSD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L164-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.tfest" href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tfest(
    data::FRD,
    p0,
    link = log ∘ abs;
    freq_weight = sqrt(data.w[1]*data.w[end]),
    refine = true,
    opt = BFGS(),
    opts = Optim.Options(
        store_trace       = true,
        show_trace        = true,
        show_every        = 1,
        iterations        = 100,
        allow_f_increases = false,
        time_limit        = 100,
        x_tol             = 0,
        f_tol             = 0,
        g_tol             = 1e-8,
        f_calls_limit     = 0,
        g_calls_limit     = 0,
    ),
)</code></pre><p>Fit a parametric transfer function to frequency-domain data.</p><p>The initial pahse of the optimization solves</p><p class="math-container">\[\operatorname{minimize}_{B,A}{|| B/l - A||}\]</p><p>and the second stage (if refine=true) solves </p><p class="math-container">\[\operatorname{minimize}_{B,A}{|| \text{link}\left(\dfrac{B}{A}\right) - \text{link}\left(l\right)||}\]</p><p>(<code>abs2(link(B/A) - link(l))</code>)</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: An <code>FRD</code> onbject with frequency domain data.</li><li><code>p0</code>: Initial parameter guess. Can be a <code>NamedTuple</code> or <code>ComponentVector</code> with fields <code>b,a</code> specifying numerator and denominator as they appear in the call to <code>tf</code>, i.e., <code>(b = [1.0], a = [1.0,1.0,1.0])</code>. Can also be an instace of <code>TransferFunction</code>.</li><li><code>link</code>: By default, phase information is discarded in the fitting. To include phase, change to <code>link = log</code>.</li><li><code>freq_weight</code>: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.</li><li><code>refine</code>: Indicate whether or not a second optimization stage is performed to refine the results of the first.</li><li><code>opt</code>: The Optim optimizer to use.</li><li><code>opts</code>: <code>Optim.Options</code> controlling the solver options.</li></ul><p>See also <a href="../api/#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous}}"><code>minimum_phase</code></a> to transform a possibly non-minimum phase system to minimum phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L632-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M" href="#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tfest(data::FRD, basis::AbstractStateSpace; 
    freq_weight = 1 ./ (data.w .+ data.w[2]),
    opt = BFGS(),
    metric::M = abs2,
    opts = Optim.Options(
        store_trace       = true,
        show_trace        = true,
        show_every        = 50,
        iterations        = 1000000,
        allow_f_increases = false,
        time_limit        = 100,
        x_tol             = 1e-5,
        f_tol             = 0,
        g_tol             = 1e-8,
        f_calls_limit     = 0,
        g_calls_limit     = 0,
)</code></pre><p>Fit a parametric transfer function to frequency-domain data using a pre-specified basis.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: An <code>FRD</code> onbject with frequency domain data.</li></ul><p>function kautz(a::AbstractVector)</p><ul><li><code>basis</code>: A basis for the estimation. See, e.g., <code>laguerre, laguerre_oo, kautz</code></li><li><code>freq_weight</code>: A vector of weights per frequency. The default is approximately <code>1/f</code>. </li><li><code>opt</code>: The Optim optimizer to use.</li><li><code>opts</code>: <code>Optim.Options</code> controlling the solver options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L746-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.welchplot" href="#ControlSystemIdentification.welchplot"><code>ControlSystemIdentification.welchplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">welchplot(d::IdData, args...; kwargs...)</code></pre><p>Plot a Wlch peridogram of the input and output timeseries. See also <a href="#ControlSystemIdentification.specplot"><code>specplot</code></a>.</p><p>Additional arguments are passed along to <code>DSP.welch_pgram</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/plotting.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.wtls_estimator" href="#ControlSystemIdentification.wtls_estimator"><code>ControlSystemIdentification.wtls_estimator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wtls_estimator(y,na,nb, σu=0)</code></pre><p>Create an estimator function for estimation of arx models in the presence of measurement noise. If the noise variance on the input <code>σu</code> (model errors) is known, this can be specified for increased accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L899-L903">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, Real}" href="#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix, Real}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DSP.resample(sys::AbstractStateSpace{&lt;:Discrete}, Qd::AbstractMatrix, newh::Real)</code></pre><p>Change sample time of covariance matrix <code>Qd</code> beloning to <code>sys</code> to <code>newh</code>. This function does not handle the measurement covariance, how to do this depends on context. If the faster sampled signal has the same measurement noise, no change should be made. If the slower sampled signal was downsampled with filtering, the measurement covariance should be increased if the system is changed to a faster sample rate. To maintain the frequency response of the system, the measurement covariance should be modified accordinly.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A discrete-time system that has dynamics noise covariance matric <code>Qd</code>.</li><li><code>Qd</code>: Covariance matrix of dynamics noise.</li><li><code>newh</code>: The new sample time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L455-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, Real}" href="#DSP.Filters.resample-Tuple{AbstractStateSpace{&lt;:Discrete}, Real}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resample(sys::AbstractStateSpace{&lt;:Discrete}, newh::Real)</code></pre><p>Change sample-time of sys to <code>newh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L445-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}" href="#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dr = resample(d::InputOutputData, f)</code></pre><p>Resample iddata <code>d</code> with fraction <code>f</code>, e.g., <code>f = fs_new / fs_original</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LowLevelParticleFilters.simulate" href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(sys, u, x0 = nothing)
simulate(sys, d, x0 = nothing)</code></pre><p>See also <a href="#ControlSystemIdentification.simplot"><code>simplot</code></a>, <a href="../validation/#StatsAPI.predict"><code>predict</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any}}" href="#StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any}}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(sys, d::AbstractIdData, args...)
predict(sys, y, u, x0 = nothing)</code></pre><p>See also <a href="#ControlSystemIdentification.predplot"><code>predplot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{TransferFunction, Any}" href="#StatsAPI.predict-Tuple{TransferFunction, Any}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yh = predict(ar::TransferFunction, y)</code></pre><p>Predict AR model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{TransferFunction, InputOutputData}" href="#StatsAPI.predict-Tuple{TransferFunction, InputOutputData}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(ARX::TransferFunction, d::InputOutputData)</code></pre><p>One step ahead prediction for an ARX process.  The length of the returned prediction is <code>length(d) - max(na, nb)</code></p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; predict(tf(1, [1, -1], 1), iddata(1:10, 1:10))
9-element Vector{Int64}:
  2
  4
  6
  8
 10
 12
 14
 16
 18</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L188-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.residuals-Tuple{TransferFunction, InputOutputData}" href="#StatsAPI.residuals-Tuple{TransferFunction, InputOutputData}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residuals(ARX::TransferFunction, d::InputOutputData)</code></pre><p>Calculates the residuals <code>v = Ay - Bu</code> of an ARX process and InputOutputData d. The length of the returned residuals is <code>length(d) - max(na, nb)</code></p><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ARX = tf(1, [1, -1], 1)
TransferFunction{Discrete{Int64}, ControlSystemsBase.SisoRational{Int64}}
  1
-----
z - 1

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; u = 1:5
1:5

julia&gt; y = lsim(ARX, u, 1:5)[1][:]
5-element Vector{Float64}:
  0.0
  1.0
  3.0
  6.0
 10.0

julia&gt; d = iddata(y, u)
InputOutput data of length 5 with 1 outputs and 1 inputs

julia&gt; residuals(ARX, d)
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/arx.jl#L138-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DelimitedFiles.writedlm" href="#DelimitedFiles.writedlm"><code>DelimitedFiles.writedlm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DelimitedFiles.writedlm(io::IO, d::AbstractIdData, args...; kwargs...)</code></pre><p>Write identification data to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/types.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.c2d" href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">c2d(w::AbstractVector{&lt;:Real}, Ts; w_prewarp = 0)
c2d(frd::FRD, Ts; w_prewarp = 0)</code></pre><p>Transform continuous-time frequency vector <code>w</code> or frequency-response data <code>frd</code> from continuous to discrete time using a bilinear (Tustin) transform. This is useful in cases where a frequency response is obtained through frequency-response analysis, and the function <a href="../ss/#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> is to be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/frd.jl#L150-L155">source</a></section><section><div><pre><code class="nohighlight hljs">Qd = c2d(sys::StateSpace{Discrete}, Q::Matrix)
Qd, Rd = c2d(sys::StateSpace{Discrete}, Q::Matrix, R::Matrix)
Qd = c2d(sys::StateSpace{Continuous}, Qc::Matrix; Ts)
Qd, Rd = c2d(sys::StateSpace{Continuous}, Qc::Matrix, R::Matrix; Ts)</code></pre><p>Sample a continuous-time covariance matrix to fit the provided discrete-time system. The measurement covariance <code>R</code> may also be provided</p><p>The method used comes from theorem 5 in the reference below.</p><p>Ref: &quot;Discrete-time Solutions to the Continuous-time Differential Lyapunov Equation With Applications to Kalman Filtering&quot;,  Patrik Axelsson and Fredrik Gustafsson</p><p>On singular covariance matrices: The traditional double integrator with covariance matrix <code>Q = diagm([0,σ²])</code> can not be sampled with this method. Instead, the input matrix (&quot;Cholesky factor&quot;) of <code>Q</code> must be manually kept track of, e.g., the noise of variance <code>σ²</code> enters like <code>N = [0, 1]</code> which is sampled using ZoH and becomes <code>Nd = [1/2 Ts^2; Ts]</code> which results in the covariance matrix <code>σ² * Nd * Nd&#39;</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/ea8fb31864bcd6a25b9359a81b4df9fc4e0b4b5c/src/ControlSystemIdentification.jl#L341-L357">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/varx/">« VARX model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 27 June 2023 13:02">Tuesday 27 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
