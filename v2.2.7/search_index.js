var documenterSearchIndex = {"docs":
[{"location":"tf/#Transfer-function-estimation","page":"Transfer-function estimation","title":"Transfer function estimation","text":"","category":"section"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Basic support for ARX/ARMAX model estimation, i.e. a model on any of the forms","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Ay = Bu + w","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Ay = Bu + Cw","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Ay = Bu + 1D w","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"is provided. The ARX estimation problem is convex and the solution is available on closed-form. Usage example:","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"N  = 2000     # Number of time steps\nt  = 1:N\nΔt = 1        # Sample time\nu  = randn(N) # A random control input\nG  = tf(0.8, [1,-0.9], 1)\ny  = lsim(G,u,t)[1][:]\nyn = y\nd  = iddata(y,u,Δt)\n\nna,nb = 1,1   # Number of polynomial coefficients\n\nGls = arx(d,na,nb,stochastic=false) # set stochastic to true to get a transfer function of MonteCarloMeasurements.Particles\n@show Gls\n# TransferFunction{ControlSystems.SisoRational{Float64}}\n#     0.8000000000000005\n# --------------------------\n# 1.0*z - 0.8999999999999997","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"As we can see, the model is perfectly recovered. In reality, the measurement signal is often affected by noise, in which case the estimation will suffer. To combat this, a few different options exist:","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"e  = randn(N)\nyn = y + e    # Measurement signal with noise\nd  = iddata(yn,u,Δt)\n\nna,nb,nc = 1,1,1\n\nGls      = arx(d,na,nb, stochastic=true)     # Regular least-squares estimation\nGtls     = arx(d,na,nb, estimator=tls)       # Total least-squares estimation\nGwtls    = arx(d,na,nb, estimator=wtls_estimator(y,na,nb)) # Weighted Total least-squares estimation\nGplr, Gn = plr(d,na,nb,nc, initial_order=20) # Pseudo-linear regression\n@show Gls; @show  Gtls; @show  Gwtls; @show  Gplr; @show  Gn;\n# TransferFunction{ControlSystems.SisoRational{MonteCarloMeasurements.Particles{Float64,500}}}\n#     0.824 ± 0.029\n# ---------------------\n# 1.0*z - 0.713 ± 0.013\n\n# Gtls = TransferFunction{ControlSystems.SisoRational{Float64}}\n#     1.848908051191616\n# -------------------------\n# 1.0*z - 0.774385918070221\n\n# Gwtls = TransferFunction{ControlSystems.SisoRational{Float64}}\n#    0.8180228878106678\n# -------------------------\n# 1.0*z - 0.891939152690534\n\n# Gplr = TransferFunction{ControlSystems.SisoRational{Float64}}\n#     0.8221837077656046\n# --------------------------\n# 1.0*z - 0.8896345125395438\n\n# Gn = TransferFunction{ControlSystems.SisoRational{Float64}}\n#     0.9347035105826179\n# --------------------------\n# 1.0*z - 0.8896345125395438","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"We now see that the estimate using standard least-squares is heavily biased and it is wrongly certain about the estimate (notice the ± in the transfer function coefficients). Regular Total least-squares does not work well in this example, since not all variables in the regressor contain equally much noise. Weighted total least-squares does a reasonable job at recovering the true model. Pseudo-linear regression also fares okay, while simultaneously estimating a noise model. The helper function wtls_estimator(y,na,nb) returns a function that performs wtls using appropriately sized covariance matrices, based on the length of y and the model orders. Weighted total least-squares estimation is provided by TotalLeastSquares.jl. See the example notebooks for more details.","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Uncertain transfer function with Particles coefficients can be used like any other model. Try, e.g., nyquistplot(Gls) to get a Nyquist plot with confidence bounds.","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"See also function arma for estimation of signal models without inputs.","category":"page"},{"location":"tf/#Time-series-modeling","page":"Transfer-function estimation","title":"Time-series modeling","text":"","category":"section"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Time-series modeling can be seen as special cases of transfer-function modeling where there are no control inputs. This package is primarily focused on control system identification, but we nevertheless provide two methods aimed at time-series estimation:","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"ar: Estimate an AR model (no input).\narma_ssa Estimate an ARMA model with estimated noise as input (no control input).","category":"page"},{"location":"tf/#Functions","page":"Transfer-function estimation","title":"Functions","text":"","category":"section"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"arx: Transfer-function estimation using closed-form solution.\narma: Estimate an ARMA model.\nar: Estimate an AR model (no input).\narma_ssa Estimate an ARMA model with estimated noise as input (no control input).\nplr: Transfer-function estimation using pseudo-linear regression\narxar: Transfer-function estimation using generalized least squares method\ngetARXregressor/getARregressor: For low-level control over the estimation","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"See docstrings for further help.","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"note: Note\nMost methods for estimation of transfer functions handle SISO, SIMO or MISO systems only. For estimation of MIMO systems, consider using state-space based methods and convert the result to a transfer function using tf after estimation if required. ","category":"page"},{"location":"tf/","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"ControlSystemIdentification.arx\nControlSystemIdentification.ar\nControlSystemIdentification.arma\nControlSystemIdentification.plr\nControlSystemIdentification.arxar\nControlSystemIdentification.getARXregressor\nControlSystemIdentification.getARregressor","category":"page"},{"location":"tf/#ControlSystemIdentification.arx","page":"Transfer-function estimation","title":"ControlSystemIdentification.arx","text":"Gtf = arx(d::AbstractIdData, na, nb; inputdelay = ones(Int, size(nb)), λ = 0, estimator=\\, stochastic=false)\n\nFit a transfer Function to data using an ARX model and equation error minimization.\n\nnb and na are the number of coefficients of the numerator and denominator polynomials.\n\nInput delay can be added via inputdelay = d, which corresponds to an additional delay of z^-d. An inputdelay = 0 results in a direct term. The highest order of the B polynomial is given by nb + inputdelay - 1.  λ > 0 can be provided for L₂ regularization. estimator defaults to \\ (least squares), alternatives are estimator = tls for total least-squares estimation.  arx(Δt,yn,u,na,nb, estimator=wtls_estimator(y,na,nb) is potentially more robust in the presence of heavy measurement noise. The number of free parameters is na+nb \n\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nSupports MISO estimation by supplying an iddata with a matrix u, with nb = [nb₁, nb₂...] and optional inputdelay = [d₁, d₂...]\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.ar","page":"Transfer-function estimation","title":"ControlSystemIdentification.ar","text":"ar(d::AbstractIdData, na; λ=0, estimator=\\, scaleB=false, stochastic=false)\n\nEstimate an AR transfer function G = 1/A, the AR process is defined as A(z⁻¹)y(t) = e(t)\n\nArguments:\n\nd: IdData, see iddata\nna: order of the model\nλ: λ > 0 can be provided for L₂ regularization\nestimator: e.g. \\,tls,irls,rtls\nscaleB: Whether or not to scale the numerator using the variance of the prediction error.\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nEstimation of AR models using least-squares is known to struggle with heavy measurement noise, using estimator = tls can improve the result in this case.\n\nExample\n\njulia> N = 10000\n10000\n\njulia> e = [-0.2; zeros(N-1)] # noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> G = tf([1, 0], [1, -0.9], 1) # AR transfer function\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z - 0.9\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> y = lsim(G, e, 1:N)[1][:] # Get output of AR transfer function from input noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> Gest = ar(iddata(y), 1) # Estimate AR transfer function from output y\nTransferFunction{Discrete{Float64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z - 0.8999999999999998\n\nSample Time: 1.0 (seconds)\nDiscrete-time transfer function model\n\njulia> G ≈ Gest # Test if estimation was correct\ntrue\n\njulia> eest = lsim(1/Gest, y, 1:N)[1][:] # recover the input noise e from output y and estimated transfer function Gest\n10000-element Vector{Float64}:\n[...]\n\njulia> isapprox(eest, e, atol = eps()) # input noise correct recovered\ntrue \n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.arma","page":"Transfer-function estimation","title":"ControlSystemIdentification.arma","text":"model = arma(d::AbstractIdData, na, nc; initial_order=20, method=:ls)\n\nEstimate a Autoregressive Moving Average model with na coefficients in the denominator and nc coefficients in the numerator. Returns the model and the estimated noise sequence driving the system.\n\nArguments:\n\nd: iddata\ninitial_order: An initial AR model of this order is used to estimate the residuals\nestimator: A function (A,y)->minimizeₓ(Ax-y) default is \\ but another option is wtls_estimator(1:length(y)-initial_order,na,nc,ones(nc))\n\nSee also estimate_residuals\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.plr","page":"Transfer-function estimation","title":"ControlSystemIdentification.plr","text":"G, Gn = plr(d::AbstractIdData,na,nb,nc; initial_order = 20)\n\nPerform pseudo-linear regression to estimate a model on the form Ay = Bu + Cw The residual sequence is estimated by first estimating a high-order arx model, whereafter the estimated residual sequence is included in a second estimation problem. The return values are the estimated system model, and the estimated noise model. G and Gn will always have the same denominator polynomial.\n\narmax is an alias for plr. See also pem, ar, arx\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.arxar","page":"Transfer-function estimation","title":"ControlSystemIdentification.arxar","text":"G, H, e = arxar(d::InputOutputData, na::Int, nb::Union{Int, Vector{Int}}, nd::Int)\n\nEstimate the ARXAR model Ay = Bu + v, where v = He and H = 1/D, using generalized least-squares method. For more information see Söderström - Convergence properties of the generalized least squares identification method, 1974. \n\nArguments:\n\nd: iddata\nna: order of A\nnb: number of coefficients in B, the order is determined by nb + inputdelay - 1. In MISO estimation it takes the form nb = [nb₁, nb₂...]. \nnd: order of D\n\nKeyword Arguments:\n\nH = nothing: prior knowledge about the AR noise model\ninputdelay = ones(Int, size(nb)): optional delay of input, inputdelay = 0 results in a direct term, takes the form inputdelay = [d₁, d₂...] in MISO estimation \nλ = 0: λ > 0 can be provided for L₂ regularization\nestimator = \\: e.g. \\,tls,irls,rtls, the latter three require using TotalLeastSquares\nδmin = 10e-4: Minimal change in the power of e, that specifies convergence.\niterations = 10: maximum number of iterations.\nverbose = false: if true, more information is printed\n\nExample:\n\njulia> N = 500 \n500\n\njulia> sim(G, u) = lsim(G, u, 1:N)[1][:]\nsim (generic function with 1 method)\n\njulia> A = tf([1, -0.8], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z - 0.8\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> B = tf([0, 1], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}\n1\n-\nz\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> G = minreal(B / A)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0\n----------\n1.0z - 0.8\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> D = tf([1, 0.7], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z + 0.7\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> H = 1 / D\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z + 0.7\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> u, e = randn(1, N), randn(1, N)\n[...]\n\njulia> y, v = sim(G, u), sim(H * (1/A), e) # simulate process\n[...]\n\njulia> d = iddata(y .+ v, u, 1)\nInputOutput data of length 500 with 1 outputs and 1 inputs\n\njulia> na, nb , nd = 1, 1, 1\n(1, 1, 1)\n\njulia> Gest, Hest, res = arxar(d, na, nb, nd)\n(G = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   0.9987917259291642\n-------------------------\n1.0z - 0.7937837464682017\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, H = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z + 0.7019519225937721\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, e = [...]\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.getARXregressor","page":"Transfer-function estimation","title":"ControlSystemIdentification.getARXregressor","text":"getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb; inputdelay = ones(Int, size(nb)))\n\nReturns a shortened output signal y and a regressor matrix A such that the least-squares ARX model estimate of order na,nb is y\\A\n\nReturn a regressor matrix used to fit an ARX model on, e.g., the form A(z)y = B(z)u with output y and input u where the order of autoregression is na, the order of input moving average is nb and an optional input delay inputdelay. Caution, changing the input delay changes the order to nb + inputdelay - 1. An inputdelay = 0 results in a direct term. \n\nExample\n\nA     = [1,2*0.7*1,1] # A(z) coeffs\nB     = [10,5] # B(z) coeffs\nu     = randn(100) # Simulate 100 time steps with Gaussian input\ny     = filt(B,A,u)\nyr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2\nx     = A\\yr # Estimate model polynomials\nplot([yr A*x], lab=[\"Signal\" \"Prediction\"])\n\nFor nonlinear ARX-models, see BasisFunctionExpansions.jl. See also arx\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.getARregressor","page":"Transfer-function estimation","title":"ControlSystemIdentification.getARregressor","text":"yt,A = getARregressor(y::AbstractVector, na)\n\nReturns values such that x = A\\yt. See getARXregressor for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/#Exported-functions-and-types","page":"API","title":"Exported functions and types","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [ControlSystemIdentification]\nPrivate = false","category":"page"},{"location":"api/#ControlSystemIdentification.FRD","page":"API","title":"ControlSystemIdentification.FRD","text":"FRD(w, r)\n\nRepresents frequency-response data. w holds the frequency vector and r the response. Methods defined on this type include\n\n+-*\nlength, vec, sqrt\nplot\nfeedback\nfreqvec\ntfest to estimate a rational model\nIndexing in the frequency domain using, e.g., G[1Hz : 5Hz], G[1rad : 5rad]\n\nIf r represents a MIMO frequency response, the dimensions are ny × nu × nω. freqresp returns a PermutedDimsArray whose .parent field follows this convention.\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.FRD-Tuple{Any, LTISystem}","page":"API","title":"ControlSystemIdentification.FRD","text":"FRD(w, sys::LTISystem)\n\nGenerate a frequency-response data object by evaluating the frequency response of sys at frequencies w.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.Hz","page":"API","title":"ControlSystemIdentification.Hz","text":"Represents frequencies in Herz for indexing of FRD objects: frd[2Hz:10Hz]\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.InputOutputData","page":"API","title":"ControlSystemIdentification.InputOutputData","text":"See iddata\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.InputOutputFreqData","page":"API","title":"ControlSystemIdentification.InputOutputFreqData","text":"See iddata\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.N4SIDStateSpace","page":"API","title":"ControlSystemIdentification.N4SIDStateSpace","text":"N4SIDStateSpace <: AbstractPredictionStateSpace\n\nThe result of statespace model estimation using the n4sid method.\n\nFields:\n\nsys: estimated model in the form of a StateSpace object\nQ: estimated covariance matrix of the states\nR: estimated covariance matrix of the measurements\nS: estimated cross covariance matrix between states and measurements\nK: kalman observer gain\nP: solution to the Riccatti equation\nx: estimated state trajectory\ns: singular values\nfve: Fraction of variance explained by singular values\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.PredictionStateSpace","page":"API","title":"ControlSystemIdentification.PredictionStateSpace","text":"PredictionStateSpace{T, ST <: AbstractStateSpace{T}, KT, QT, RT, ST2} <: AbstractPredictionStateSpace{T}\nPredictionStateSpace(sys, K, Q=nothing, R=nothing, S=nothing)\n\nA statespace type that contains an additional Kalman-filter model for prediction purposes.\n\nArguments:\n\nsys: DESCRIPTION\nK: Infinite-horizon Kalman gain\nQ = nothing: Dynamics covariance\nR = nothing: Measurement covariance\nS = nothing: Cross-covariance\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.rad","page":"API","title":"ControlSystemIdentification.rad","text":"Represents frequencies in rad/s for indexing of FRD objects: frd[2rad:10rad]\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.apply_fun","page":"API","title":"ControlSystemIdentification.apply_fun","text":"apply_fun(fun, d::InputOutputData)\n\nApply fun(y) to all time series y[,u,[x]] ∈ d and return a new iddata with the transformed series.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}","page":"API","title":"ControlSystemIdentification.ar","text":"ar(d::AbstractIdData, na; λ=0, estimator=\\, scaleB=false, stochastic=false)\n\nEstimate an AR transfer function G = 1/A, the AR process is defined as A(z⁻¹)y(t) = e(t)\n\nArguments:\n\nd: IdData, see iddata\nna: order of the model\nλ: λ > 0 can be provided for L₂ regularization\nestimator: e.g. \\,tls,irls,rtls\nscaleB: Whether or not to scale the numerator using the variance of the prediction error.\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nEstimation of AR models using least-squares is known to struggle with heavy measurement noise, using estimator = tls can improve the result in this case.\n\nExample\n\njulia> N = 10000\n10000\n\njulia> e = [-0.2; zeros(N-1)] # noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> G = tf([1, 0], [1, -0.9], 1) # AR transfer function\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z - 0.9\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> y = lsim(G, e, 1:N)[1][:] # Get output of AR transfer function from input noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> Gest = ar(iddata(y), 1) # Estimate AR transfer function from output y\nTransferFunction{Discrete{Float64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z - 0.8999999999999998\n\nSample Time: 1.0 (seconds)\nDiscrete-time transfer function model\n\njulia> G ≈ Gest # Test if estimation was correct\ntrue\n\njulia> eest = lsim(1/Gest, y, 1:N)[1][:] # recover the input noise e from output y and estimated transfer function Gest\n10000-element Vector{Float64}:\n[...]\n\njulia> isapprox(eest, e, atol = eps()) # input noise correct recovered\ntrue \n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}","page":"API","title":"ControlSystemIdentification.arma","text":"model = arma(d::AbstractIdData, na, nc; initial_order=20, method=:ls)\n\nEstimate a Autoregressive Moving Average model with na coefficients in the denominator and nc coefficients in the numerator. Returns the model and the estimated noise sequence driving the system.\n\nArguments:\n\nd: iddata\ninitial_order: An initial AR model of this order is used to estimate the residuals\nestimator: A function (A,y)->minimizeₓ(Ax-y) default is \\ but another option is wtls_estimator(1:length(y)-initial_order,na,nc,ones(nc))\n\nSee also estimate_residuals\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}","page":"API","title":"ControlSystemIdentification.arma_ssa","text":"arma_ssa(d::AbstractIdData, na, nc; L=nothing, estimator=\\, robust=false)\n\nFit arma models using Singular Spectrum Analysis (SSA). A low-rank factorization (svd or robust svd) is performed on the data in order to decompose the signal and the noise. The noise is then used as input to fit an arma model.\n\nArguments:\n\nd:  iddata\nna: number of denominator parameters\nnc: number of numerator parameters\nL:  length of the lag-embedding used to separate signal and noise. nothing corresponds to automatic selection.\nestimator: The function to solve the least squares problem. Examples \\,tls,irls,rtls.\nrobust: Use robust PCA to be resistant to outliers.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}","page":"API","title":"ControlSystemIdentification.arx","text":"Gtf = arx(d::AbstractIdData, na, nb; inputdelay = ones(Int, size(nb)), λ = 0, estimator=\\, stochastic=false)\n\nFit a transfer Function to data using an ARX model and equation error minimization.\n\nnb and na are the number of coefficients of the numerator and denominator polynomials.\n\nInput delay can be added via inputdelay = d, which corresponds to an additional delay of z^-d. An inputdelay = 0 results in a direct term. The highest order of the B polynomial is given by nb + inputdelay - 1.  λ > 0 can be provided for L₂ regularization. estimator defaults to \\ (least squares), alternatives are estimator = tls for total least-squares estimation.  arx(Δt,yn,u,na,nb, estimator=wtls_estimator(y,na,nb) is potentially more robust in the presence of heavy measurement noise. The number of free parameters is na+nb \n\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nSupports MISO estimation by supplying an iddata with a matrix u, with nb = [nb₁, nb₂...] and optional inputdelay = [d₁, d₂...]\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arxar-Tuple{InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}","page":"API","title":"ControlSystemIdentification.arxar","text":"G, H, e = arxar(d::InputOutputData, na::Int, nb::Union{Int, Vector{Int}}, nd::Int)\n\nEstimate the ARXAR model Ay = Bu + v, where v = He and H = 1/D, using generalized least-squares method. For more information see Söderström - Convergence properties of the generalized least squares identification method, 1974. \n\nArguments:\n\nd: iddata\nna: order of A\nnb: number of coefficients in B, the order is determined by nb + inputdelay - 1. In MISO estimation it takes the form nb = [nb₁, nb₂...]. \nnd: order of D\n\nKeyword Arguments:\n\nH = nothing: prior knowledge about the AR noise model\ninputdelay = ones(Int, size(nb)): optional delay of input, inputdelay = 0 results in a direct term, takes the form inputdelay = [d₁, d₂...] in MISO estimation \nλ = 0: λ > 0 can be provided for L₂ regularization\nestimator = \\: e.g. \\,tls,irls,rtls, the latter three require using TotalLeastSquares\nδmin = 10e-4: Minimal change in the power of e, that specifies convergence.\niterations = 10: maximum number of iterations.\nverbose = false: if true, more information is printed\n\nExample:\n\njulia> N = 500 \n500\n\njulia> sim(G, u) = lsim(G, u, 1:N)[1][:]\nsim (generic function with 1 method)\n\njulia> A = tf([1, -0.8], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z - 0.8\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> B = tf([0, 1], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}\n1\n-\nz\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> G = minreal(B / A)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0\n----------\n1.0z - 0.8\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> D = tf([1, 0.7], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z + 0.7\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> H = 1 / D\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z + 0.7\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> u, e = randn(1, N), randn(1, N)\n[...]\n\njulia> y, v = sim(G, u), sim(H * (1/A), e) # simulate process\n[...]\n\njulia> d = iddata(y .+ v, u, 1)\nInputOutput data of length 500 with 1 outputs and 1 inputs\n\njulia> na, nb , nd = 1, 1, 1\n(1, 1, 1)\n\njulia> Gest, Hest, res = arxar(d, na, nb, nd)\n(G = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   0.9987917259291642\n-------------------------\n1.0z - 0.7937837464682017\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, H = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z + 0.7019519225937721\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, e = [...]\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.coherence-Tuple{ControlSystemIdentification.AbstractIdData}","page":"API","title":"ControlSystemIdentification.coherence","text":"κ = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming)\n\nCalculates the magnitude-squared coherence Function. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ << 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy. κ: Coherence function (not squared) N: Noise model\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.coherenceplot","page":"API","title":"ControlSystemIdentification.coherenceplot","text":"coherenceplot(d, [(;n=..., noverlap=...); hz=false)\n\nCalculates and plots the (squared) coherence Function κ. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ << 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy.\n\nhz indicates Hertz instead of rad/s\n\nKeyword arguments to coherence are supplied as a named tuple as a second positional argument .\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.crosscorplot","page":"API","title":"ControlSystemIdentification.crosscorplot","text":"crosscorplot(data, [lags])\n\nPlot the cross correlation betweein input and output for lags that default to 10% of the length of the dataset on the negative side and 50% on the positive side but no more than 100 on each side.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.era","page":"API","title":"ControlSystemIdentification.era","text":"era(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r; p = l, λ=0)\n\nEigenvalue realization algorithm. Uses okid to find the Markov parameters as an initial step.\n\nArguments:\n\nr: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, for era, p defaults to l, while when calling okid directly, p defaults to 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.era-Tuple{AbstractArray{var\"#s156\", 3} where var\"#s156\", Any, Int64, Int64, Int64}","page":"API","title":"ControlSystemIdentification.era","text":"era(YY::AbstractArray{<:Any, 3}, Ts, r::Int, m::Int, n::Int)\n\nEigenvalue realization algorithm.\n\nArguments:\n\nYY: Markov parameters (impulse response) size n_out×n_in×n_time\nTs: Sample time\nr: Model order\nm: Number of rows in Hankel matrix\nn: Number of columns in Hankel matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}","page":"API","title":"ControlSystemIdentification.estimate_residuals","text":"estimate_residuals(model, y)\n\nEstimate the residuals driving the dynamics of an ARMA model.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.estimate_x0","page":"API","title":"ControlSystemIdentification.estimate_x0","text":"estimate_x0(sys, d, n = min(length(d), 3 * slowest_time_constant(sys)); fixed = fill(NaN, sys.nx)\n\nEstimate the initial state of the system \n\nArguments:\n\nd: iddata\nn: Number of samples to use.\nfixed: If a vector of the same length as x0 is provided, finite values indicate fixed values that are not to be estimated, while nonfinite values are free.\n\nExample\n\nsys   = ssrand(2,3,4, Ts=1)\nx0    = randn(sys.nx)\nu     = randn(sys.nu, 100)\ny,t,x = lsim(sys, u; x0)\nd     = iddata(y, u, 1)\nx0h   = estimate_x0(sys, d, 8, fixed=[Inf, x0[2], Inf, Inf])\nx0h[2] == x0[2] # Should be exact equality\nnorm(x0-x0h)    # Should be small\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{var\"#s162\"} where var\"#s162\"<:Discrete, AbstractMatrix{T} where T}","page":"API","title":"ControlSystemIdentification.filter_bank","text":"filter_bank(basis::AbstractStateSpace{<:Discrete}, signal::AbstractMatrix)\n\nFilter signal through all systems in basis\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.find_na","page":"API","title":"ControlSystemIdentification.find_na","text":"find_na(y::AbstractVector,n::Int)\n\nPlots the RMSE and AIC For model orders up to n. Useful for model selection\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.find_nanb","page":"API","title":"ControlSystemIdentification.find_nanb","text":"find_nanb(d::InputOutputData,na,nb)\n\nPlots the RMSE and AIC For model orders up to n. Useful for model selection\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.find_similarity_transform","page":"API","title":"ControlSystemIdentification.find_similarity_transform","text":"find_similarity_transform(sys1, sys2)\n\nFind T such that ControlSystems.similarity_transform(sys1, T) == sys2\n\nRef: Minimal state-space realization in linear system theory: an overview, B. De Schutter\n\njulia> T = randn(3,3);\n\njulia> sys1 = ssrand(1,1,3);\n\njulia> sys2 = ControlSystems.similarity_transform(sys1, T);\n\n\njulia> T2 = find_similarity_transform(sys1, sys2);\n\njulia> T2 ≈ T\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.freqvec-Tuple{Any, Any}","page":"API","title":"ControlSystemIdentification.freqvec","text":"freqvec(h, k)\n\nReturn a frequency vector of length k for systems with sample time h.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Any, Any}","page":"API","title":"ControlSystemIdentification.getARXregressor","text":"getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb; inputdelay = ones(Int, size(nb)))\n\nReturns a shortened output signal y and a regressor matrix A such that the least-squares ARX model estimate of order na,nb is y\\A\n\nReturn a regressor matrix used to fit an ARX model on, e.g., the form A(z)y = B(z)u with output y and input u where the order of autoregression is na, the order of input moving average is nb and an optional input delay inputdelay. Caution, changing the input delay changes the order to nb + inputdelay - 1. An inputdelay = 0 results in a direct term. \n\nExample\n\nA     = [1,2*0.7*1,1] # A(z) coeffs\nB     = [10,5] # B(z) coeffs\nu     = randn(100) # Simulate 100 time steps with Gaussian input\ny     = filt(B,A,u)\nyr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2\nx     = A\\yr # Estimate model polynomials\nplot([yr A*x], lab=[\"Signal\" \"Prediction\"])\n\nFor nonlinear ARX-models, see BasisFunctionExpansions.jl. See also arx\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.getARregressor-Tuple{AbstractVector{T} where T, Any}","page":"API","title":"ControlSystemIdentification.getARregressor","text":"yt,A = getARregressor(y::AbstractVector, na)\n\nReturns values such that x = A\\yt. See getARXregressor for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.iddata","page":"API","title":"ControlSystemIdentification.iddata","text":"iddata(y,       Ts = nothing)\niddata(y, u,    Ts = nothing)\niddata(y, u, x, Ts = nothing)\n\nReturns the appropriate identification-data object, depending on the input.\n\nArguments\n\ny::AbstractArray: output data (required)\nu::AbstractArray: input data (if available)\nx::AbstractArray: state data (if available)\nTs::Union{Real,Nothing} = nothing: optional sample time\n\nIf the time-series are multivariate, time is in the last dimension.\n\nOperations on iddata\n\nprefilter\nresample\nappend two along the time dimension [d1 d2]\nindex time series d[output_index, input_index]\nindex the time axis with indices d[time_indices]\nindex the time axis with seconds d[3Sec:12Sec] (using ControlSystemIdentification: Sec)\naccess number of inputs, outputs and sample time: d.nu, d.ny, d.Ts\naccess the time time vector d.t\npremultiply to scale outputs C * d\npostmultiply to scale inputs d * B\nwritedlm\nramp_in, ramp_out\nplot\nspecplot\n\nExamples\n\njulia> iddata(randn(10))\nOutput data of length 10 with 1 outputs\n\njulia> iddata(randn(10), randn(10), 1)\nInputOutput data of length 10 with 1 outputs and 1 inputs\n\njulia> d = iddata(randn(2, 10), randn(3, 10), 0.1)\nInputOutput data of length 10 with 2 outputs and 3 inputs\n\njulia> [d d] # Concatenate along time\nInputOutput data of length 20 with 2 outputs and 3 inputs\n\njulia> d[1:3]\nInputOutput data of length 3 with 2 outputs and 3 inputs\n\njulia> d.nu\n3\n\njulia> d.t # access time vector\n0.0:0.1:0.9\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector{T} where T}","page":"API","title":"ControlSystemIdentification.iddata","text":"iddata(y::AbstractArray, u::AbstractArray, w::AbstractVector)\n\nCreate a frequency-domain input-output data object. w is expected to be in rad/s.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}","page":"API","title":"ControlSystemIdentification.impulseest","text":"ir, t, Σ = impulseest(d::AbstractIdData, n; λ=0, estimator=ls)\n\nEstimates the system impulse response by fitting an n:th order FIR model. Returns impulse-response estimate, time vector and covariance matrix. See also impulseestplot\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.impulseestplot","page":"API","title":"ControlSystemIdentification.impulseestplot","text":"impulseestplot(data,n)\n\nEstimates the system impulse response by fitting an n:th order FIR model and plots the result with a 95% confidence band. See also impulseestplot\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.kautz-Tuple{AbstractVector{T} where T, Any}","page":"API","title":"ControlSystemIdentification.kautz","text":"kautz(a::Vector, h)\n\nConstruct a discrete-time Kautz basis of length with poles at a amd sample time h.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.laguerre-Tuple{Any, Any}","page":"API","title":"ControlSystemIdentification.laguerre","text":"laguerre(a::Number, Nq)\n\nConstruct a Laguerre basis of length Nq with poles at a.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}","page":"API","title":"ControlSystemIdentification.laguerre_oo","text":"laguerre_oo(a::Number, Nq)\n\nConstruct an output orthogonalized Laguerre basis of length Nq with poles at a.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous, S} where S<:(ControlSystems.SisoTf{T} where T)}","page":"API","title":"ControlSystemIdentification.minimum_phase","text":"minimum_phase(G)\n\nMove zeros and poles of G from the unstable half plane to the stable. If G is a statespace system, it's converted to a transfer function first. This can incur loss of precision.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any, N} where N}","page":"API","title":"ControlSystemIdentification.model_spectrum","text":"model_spectrum(f, h, args...; kwargs...)\n\nArguments:\n\nf: the model-estimation function, e.g., ar,arma\nh: The sample time\nargs: arguments to f\nkwargs: keyword arguments to f\n\nExample:\n\nusing ControlSystemIdentification, DSP\nT = 1000\ns = sin.((1:T) .* 2pi/10)\nS1 = spectrogram(s,window=hanning)\nestimator = model_spectrum(ar,1,2)\nS2 = spectrogram(s,estimator,window=rect)\nplot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.n4sid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}","page":"API","title":"ControlSystemIdentification.n4sid","text":"res = n4sid(data, r=:auto; verbose=false)\n\nEstimate a statespace model using the n4sid method. Returns an object of type N4SIDStateSpace where the model is accessed as res.sys.\n\nImplements the simplified algorithm (alg 2) from \"N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems\" PETER VAN OVERSCHEE and BART DE MOOR\n\nThe frequency weighting is borrowing ideas from \"Frequency Weighted Subspace Based System Identification in the Frequency Domain\", Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).\n\nArguments:\n\ndata: Identification data data = iddata(y,u)\nr: Rank of the model (model order)\nverbose: Print stuff?\nWf: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like Wf = Bandstop(lower, upper, fs=1/Ts) to indicate that there are disturbances outside this band.\ni: Algorithm parameter, generally no need to tune this\nγ: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.\nzeroD: defaults to false\n\nSee also the newer implementation subspaceid which allows you to choose between different weightings (n4sid being one of them). A more accurate prediciton model can sometimes be obtained using newpem, which is also unbiased for closed-loop data.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.newpem-Union{Tuple{RE}, Tuple{F}, Tuple{Any, Any}} where {F, RE}","page":"API","title":"ControlSystemIdentification.newpem","text":"sys, x0, res = newpem(\n    d,\n    nx;\n    zeroD  = true,\n    focus  = :prediction,\n    stable = true,\n    sys0   = subspaceid(d, nx; zeroD, focus, stable),\n    metric = abs2,\n    regularizer = (p, P) -> 0,\n    optimizer = BFGS(\n        linesearch = LineSearches.BackTracking(),\n    ),\n    store_trace = true,\n    show_trace  = true,\n    show_every  = 50,\n    iterations  = 10000,\n    time_limit  = 100,\n    x_tol       = 0,\n    f_abstol    = 0,\n    g_tol       = 1e-12,\n    f_calls_limit = 0,\n    g_calls_limit = 0,\n    allow_f_increases = false,\n)\n\nA new implementation of the prediction-error method (PEM). Note that this is an experimental implementation and subject to breaking changes not respecting semver.\n\nThe prediction-error method is an iterative, gradient-based optimization problem, as such, it can be extra sensitive to signal scaling, and it's recommended to perform scaling to d before estimation, e.g., by pre and post-multiplying with diagonal matrices d̃ = Dy*d*Du, and apply the inverse scaling to the resulting system. In this case, we have\n\nD_y y = G D_u u  y = D_y^-1 G D_u u\n\nhence G = Dy \\ G̃ * Du where $ G̃ $ is the plant estimated for the scaled iddata.\n\nArguments:\n\nd: iddata\nnx: Model order\nzeroD: Force zero D matrix\nstable if true, stability of the estimated system will be enforced by eigenvalue reflection using schur_stab with ϵ=Ts/100 (default). If stable is a real value, the value is used instead of the default ϵ.\nsys0: Initial guess, if non provided, subspaceid is used as initial guess.\nfocus: prediction or :simulation. If :simulation, hte K matrix will be zero.\noptimizer: One of Optim's optimizers\nmetric: The metric used to measure residuals. Try, e.g., abs for better resistance to outliers.\n\nThe rest of the arguments are related to Optim.Options.\n\nregularizer: A function of the parameter vector and the corresponding PredictionStateSpace/StateSpace system that can be used to regularize the estimate.\n\nExample\n\nusing ControlSystemIdentification, ControlSystems, Plots\nG = DemoSystems.doylesat()\nT = 1000  # Number of time steps\nTs = 0.01 # Sample time\nsys = c2d(G, Ts)\nnx = sys.nx\nnu = sys.nu\nny = sys.ny\nx0 = zeros(nx) # actual initial state\nsim(sys, u, x0 = x0) = lsim(sys, u; x0)[1]\n\nσy = 1e-1 # Noise covariance\n\nu  = randn(nu, T)\ny  = sim(sys, u, x0)\nyn = y .+ σy .* randn.() # Add measurement noise\nd  = iddata(yn, u, Ts)\n\nsysh, x0h, opt = ControlSystemIdentification.newpem(d, nx, show_every=10)\n\nplot(\n    bodeplot([sys, sysh]),\n    predplot(sysh, d, x0h), # Include the estimated initial state in the prediction\n)\n\nExtended help\n\nThis implementation uses a tridiagonal parametrization of the A-matrix that has been shown to be favourable from an optimization perspective.¹ The initial guess sys0 is automatically transformed to a special tridiagonal modal form.  [1]: Mckelvey, Tomas & Helmersson, Anders. (1997). State-space parametrizations of multivariable linear systems using tridiagonal matrix forms.\n\nThe parameter vector used in the optimizaiton takes the following form\n\np = [trivec(A); vec(B); vec(C); vec(D); vec(K); vec(x0)]\n\nWhere ControlSystemIdentification.trivec vectorizes the -1,0,1 diagonals of A. If focus = :simulation, K is omitted, and if zeroD = true, D is omitted.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}","page":"API","title":"ControlSystemIdentification.noise_model","text":"noise_model(sys::AbstractPredictionStateSpace)\n\nReturn a model of the noise driving the system, v, in\n\nx = Ax + Bu + Kv\ny = Cx + Du + v\n\nThe model neglects u and is given by\n\nx = Ax + Kv\ny = Cx + v\n\nAlso called the \"innovation form\". This function calls ControlSystems.innovation_form.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.okid","page":"API","title":"ControlSystemIdentification.okid","text":"H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)\n\nObserver Kalman filter identification. Returns the Markov parameters H size n_out×n_in×l+1\n\nArguments:\n\nnx: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, try setting p around the same value as l.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.pem-Tuple{Any}","page":"API","title":"ControlSystemIdentification.pem","text":"This function is deprecated, see newpem\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}","page":"API","title":"ControlSystemIdentification.plr","text":"G, Gn = plr(d::AbstractIdData,na,nb,nc; initial_order = 20)\n\nPerform pseudo-linear regression to estimate a model on the form Ay = Bu + Cw The residual sequence is estimated by first estimating a high-order arx model, whereafter the estimated residual sequence is included in a second estimation problem. The return values are the estimated system model, and the estimated noise model. G and Gn will always have the same denominator polynomial.\n\narmax is an alias for plr. See also pem, ar, arx\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.predplot","page":"API","title":"ControlSystemIdentification.predplot","text":"predplot(sys, data, x0=nothing; ploty=true, plote=false, h=1)\n\nPlot system simulation and measured output to compare them. ploty determines whether or not to plot the measured signal plote determines whether or not to plot the residual h is the prediction horizon.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.prefilter-Tuple{Any, InputOutputData}","page":"API","title":"ControlSystemIdentification.prefilter","text":"prefilter(f, d::InputOutputData)\n\nApply filter coefficients to identification data\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}","page":"API","title":"ControlSystemIdentification.prefilter","text":"prefilter(d::AbstractIdData, responsetype::FilterType)\n\nFilter both input and output of the identification data using zero-phase filtering (filtfilt). Since both input and output is filtered, linear identification will not be affected in any other way than to focus the fit on the selected frequency range, i.e. the range that has high gain in the provided filter. Note, if the system that generated d is nonlinear, identification might be severely impacted by this transformation. Verify linearity with, e.g., coherenceplot.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}","page":"API","title":"ControlSystemIdentification.prefilter","text":"prefilter(d::AbstractIdData, l::Number, u::Number)\n\nFilter input and output with a bandpass filter between l and u Hz. If l = 0 a lowpass filter will be used, and if u = Inf a highpass filter will be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.ramp_in-Tuple{InputOutputData, Int64}","page":"API","title":"ControlSystemIdentification.ramp_in","text":"ramp_in(d::InputOutputData, h::Int; rev = false)\n\nMultiply the initial h samples of input and output signals with a linearly increasing ramp.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.ramp_out-Tuple{InputOutputData, Int64}","page":"API","title":"ControlSystemIdentification.ramp_out","text":"ramp_out(d::InputOutputData, h::Int)\n\nMultiply the final h samples of input and output signals with a linearly decreasing  ramp.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.schur_stab-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"API","title":"ControlSystemIdentification.schur_stab","text":"schur_stab(A::AbstractMatrix{T}, ϵ = 0.01)\n\nStabilize the eigenvalues of discrete-time matrix A by transforming A to complex Schur form and projecting unstable eigenvalues 1-ϵ < λ ≤ 2 into the unit disc. Eigenvalues > 2 are set to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.simplot","page":"API","title":"ControlSystemIdentification.simplot","text":"simplot(sys, data, x0=nothing; ploty=true, plote=false)\n\nPlot system simulation and measured output to compare them. ploty determines whether or not to plot the measured signal plote determines whether or not to plot the residual\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.specplot","page":"API","title":"ControlSystemIdentification.specplot","text":"specplot(d::IdData)\n\nPlot a spectrogram of the input and output timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any, N} where N}","page":"API","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(frd::FRD, args...; estimate_x0 = false, kwargs...)\n\nIf a frequency-reponse data object is supplied\n\nThe FRD will be automatically converted to an InputOutputFreqData\nestimate_x0 is by default set to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputData, Any}} where {F1, F2, F3}","page":"API","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(\n    data::InputOutputData,\n    nx = :auto;\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used\n    s1 = r, # number of past outputs\n    s2 = r, # number of past inputs\n    W = :MOESP,\n    zeroD = false,\n    stable = true, \n    focus = :prediction,\n    svd::F1 = svd!,\n    scaleU = true,\n    Aestimator::F2 = \\,\n    Bestimator::F3 = \\,\n    weights = nothing,\n)\n\nEstimate a state-space model using subspace-based identification.\n\nRef: Ljung, Theory for the user.\n\nArguments:\n\ndata: Identification data iddata\nnx: Rank of the model (model order)\nverbose: Print stuff?\nr: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.\ns1: past horizon of outputs\ns2: past horizon of inputs\nW: Weight type, choose between :MOESP, :CVA, :N4SID, :IVM\nzeroD: Force the D matrix to be zero.\nstable: Stabilize unstable system using eigenvalue reflection.\nfocus: :prediction or simulation\nsvd: The function to use for svd\nscaleU: Rescale the input channels to have the same energy.\nAestimator: Estimator function used to estimate A,C.\nBestimator: Estimator function used to estimate B,D.\nweights: A vector of weights can be provided if the Bestimator is wls. \n\nExtended help\n\nA more accurate prediciton model can sometimes be obtained using newpem, which is also unbiased for closed-loop data (subspaceid is biased for closed-loop data, see example in the docs). The prediction-error method is iterative and generally more expensive than subspaceid, and uses this function (by default) to form the initial guess for the optimization.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.subspaceid-Union{Tuple{InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{InputOutputFreqData, Real}, Tuple{InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}","page":"API","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(data::InputOutputFreqData,\n    Ts = data.Ts,\n    nx = :auto;\n    cont = false,\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order\n    zeroD = false,\n    estimate_x0 = true,\n    stable = true, \n    svd = svd!,\n    Aestimator = \\,\n    Bestimator = \\,\n    weights = nothing\n)\n\nEstimate a state-space model using subspace-based identification in the frequency domain.\n\nArguments:\n\ndata: A frequency-domain identification data object.\nTs: Sample time at which the data was collected\nnx: Desired model order, an interer or :auto.\ncont: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function d2c.\nverbose: Print stuff?\nr: Internal model order, must be ≥ nx.\nzeroD: Force the D matrix to be zero.\nestimate_x0: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.\nstable: For the model to be stable (uses schur_stab).\nsvd: The svd function to use.\nAestimator: The estimator of the A matrix (and initial C-matrix).\nBestimator: The estimator of B/D and C/D matrices.\nweights: An optional vector of frequency weights of the same length as the number of frequencies in `data.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.tfest","page":"API","title":"ControlSystemIdentification.tfest","text":"H, N = tfest(data, σ = 0.05)\n\nEstimate a transfer function model using the Correlogram approach. Both H and N are of type FRD (frequency-response data).\n\nσ determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger σ implies less smoothing.\nH = Syu/Suu             Process transfer function\nN = Sy - |Syu|²/Suu     Noise PSD\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.tfest-2","page":"API","title":"ControlSystemIdentification.tfest","text":"tfest(\n    data::FRD,\n    p0,\n    link = log ∘ abs;\n    freq_weight = sqrt(data.w[1]*data.w[end]),\n    refine = true,\n    opt = BFGS(),\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 1,\n        iterations        = 100,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 0,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n    ),\n)\n\nFit a parametric transfer function to frequency-domain data.\n\nThe initial pahse of the optimization solves\n\noperatornameminimize_BA Bl - A\n\nand the second stage (if refine=true) solves \n\noperatornameminimize_BA textlinkleft(dfracBAright) - textlinkleft(lright)\n\n(abs2(link(B/A) - link(l)))\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\np0: Initial parameter guess. Can be a NamedTuple or ComponentVector with fields b,a specifying numerator and denominator as they appear in the call to tf, i.e., (b = [1.0], a = [1.0,1.0,1.0]). Can also be an instace of TransferFunction.\nlink: By default, phase information is discarded in the fitting. To include phase, change to link = log.\nfreq_weight: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.\nrefine: Indicate whether or not a second optimization stage is performed to refine the results of the first.\nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\nSee also minimum_phase to transform a possibly non-minimum phase system to minimum phase.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M","page":"API","title":"ControlSystemIdentification.tfest","text":"tfest(data::FRD, basis::AbstractStateSpace; \n    freq_weight = 1 ./ (data.w .+ data.w[2]),\n    opt = BFGS(),\n    metric::M = abs2,\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 50,\n        iterations        = 1000000,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 1e-5,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n)\n\nFit a parametric transfer function to frequency-domain data using a pre-specified basis.\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\n\nfunction kautz(a::AbstractVector)\n\nbasis: A basis for the estimation. See, e.g., laguerre, laguerre_oo, kautz\nfreq_weight: A vector of weights per frequency. The default is approximately 1/f. \nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.wtls_estimator","page":"API","title":"ControlSystemIdentification.wtls_estimator","text":"wtls_estimator(y,na,nb, σu=0)\n\nCreate an estimator function for estimation of arx models in the presence of measurement noise. If the noise variance on the input σu (model errors) is known, this can be specified for increased accuracy.\n\n\n\n\n\n","category":"function"},{"location":"api/#DSP.Filters.resample-Tuple{AbstractStateSpace{var\"#s164\"} where var\"#s164\"<:Discrete, AbstractMatrix{T} where T, Real}","page":"API","title":"DSP.Filters.resample","text":"DSP.resample(sys::AbstractStateSpace{<:Discrete}, Qd::AbstractMatrix, newh::Real)\n\nChange sample time of covariance matrix Qd beloning to sys to newh. This function does not handle the measurement covariance, how to do this depends on context. If the faster sampled signal has the same measurement noise, no change should be made. If the slower sampled signal was downsampled with filtering, the measurement covariance should be increased if the system is changed to a faster sample rate. To maintain the frequency response of the system, the measurement covariance should be modified accordinly.\n\nArguments:\n\nsys: A discrete-time system that has dynamics noise covariance matric Qd.\nQd: Covariance matrix of dynamics noise.\nnewh: The new sample time.\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Filters.resample-Tuple{AbstractStateSpace{var\"#s164\"} where var\"#s164\"<:Discrete, Real}","page":"API","title":"DSP.Filters.resample","text":"resample(sys::AbstractStateSpace{<:Discrete}, newh::Real)\n\nChange sample-time of sys to newh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}","page":"API","title":"DSP.Filters.resample","text":"dr = resample(d::InputOutputData, f)\n\nResample iddata d with fraction f, e.g., f = fs_new / fs_original.\n\n\n\n\n\n","category":"method"},{"location":"api/#LowLevelParticleFilters.simulate","page":"API","title":"LowLevelParticleFilters.simulate","text":"simulate(sys, u, x0 = nothing)\nsimulate(sys, d, x0 = nothing)\n\nSee also simplot, predict\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}","page":"API","title":"StatsAPI.predict","text":"predict(sys, d::AbstractIdData, args...)\npredict(sys, y, u, x0 = nothing)\n\nSee also predplot\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{TransferFunction, Any}","page":"API","title":"StatsAPI.predict","text":"yh = predict(ar::TransferFunction, y)\n\nPredict AR model\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{TransferFunction, InputOutputData}","page":"API","title":"StatsAPI.predict","text":"predict(ARX::TransferFunction, d::InputOutputData)\n\nOne step ahead prediction for an ARX process.  The length of the returned prediction is length(d) - max(na, nb)\n\nExample:\n\njulia> predict(tf(1, [1, -1], 1), iddata(1:10, 1:10))\n9-element Vector{Int64}:\n  2\n  4\n  6\n  8\n 10\n 12\n 14\n 16\n 18\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.residuals-Tuple{TransferFunction, InputOutputData}","page":"API","title":"StatsAPI.residuals","text":"residuals(ARX::TransferFunction, d::InputOutputData)\n\nCalculates the residuals v = Ay - Bu of an ARX process and InputOutputData d. The length of the returned residuals is length(d) - max(na, nb)\n\nExample:\n\njulia> ARX = tf(1, [1, -1], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}\n  1\n-----\nz - 1\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> u = 1:5\n1:5\n\njulia> y = lsim(ARX, u, 1:5)[1][:]\n5-element Vector{Float64}:\n  0.0\n  1.0\n  3.0\n  6.0\n 10.0\n\njulia> d = iddata(y, u)\nInputOutput data of length 5 with 1 outputs and 1 inputs\n\njulia> residuals(ARX, d)\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"DelimitedFiles.writedlm","category":"page"},{"location":"api/#DelimitedFiles.writedlm","page":"API","title":"DelimitedFiles.writedlm","text":"DelimitedFiles.writedlm(io::IO, d::AbstractIdData, args...; kwargs...)\n\nWrite identification data to disk.\n\n\n\n\n\n","category":"function"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"A typical model for a temperature-controlled system is ","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"tau dot T = -T  + Bu + c","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"where T is the temperature, u the control signal and c a constant offset, e.g., related to the temperature surrounding the controlled system. The time constant tau captures the relation between stored energy and the resistance to heat flow and determines how fast the temperature is changing. This system can be written on transfer-function form like (omitting c)","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"dfracBtau s + 1U(s)","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"This is a simple first-order transfer function which can be estimated with, e.g., the functions arx or plr. To illustrate this, we create such a system and simulate some data from it.","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"using ControlSystems, ControlSystemIdentification, Plots\nw = 2pi .* exp10.(LinRange(-3, log10(0.5), 500))\nG0 = tf(1, [10, 1]) # The true system, 10ẋ = -x + u\nG = c2d(G0, 1)      # discretize with a sample time of 1s\nprintln(\"True system\")\ndisplay(G0)\n\nu = sign.(sin.((0:0.01:20) .^ 2))' # sample a control input for identification\ny, t, x = lsim(ss(G), u) # Simulate the true system to get test data\nyn = y .+ 0.2 .* randn.() # add measurement noise\ndata = iddata(yn, u, t[2] - t[1]) # create a data object\nplot(data)","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"We see that the data we're going to use for identification is a chirp input. Chirps are excellent for identification as they have a well defined and easily controllable interval of frequencies for identification. We start by inspecting the coherence plot to ensure that the data is suitable for identification of a linear system","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"coherenceplot(data, hz=true)","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"The coherence is high for all frequencies spanned by the chirp, after which it drops significantly. This implies that we can only ever trust the identified model to be accurate up to the highest frequency that was present in the chirp input.","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"Next we set the parameters for the estimation, the numerator and denominator have one parameter each, so we set n_a = n_b = 1 and estimate two models.","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"na, nb = 1, 1 # number of parameters in denominator and numerator\nGh = arx(data, na, nb, estimator = wtls_estimator(data.y, na, nb)) # estimate an arx model\nGh2, noise_model = plr(data, na, nb, 1) # try another identification method\n\nGh, Gh2","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"Least-squares estimation of ARX models from data with high measurement noise is known to lead to models with poor low-frequency fit, we therefore used the wtls_estimator(data.y, na, nb) which performs the estimation with total-least squares.","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"We can plot the results in several different ways:","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"# Plot results\nprintln(\"Estimated system in continuous time\")\ndisplay(d2c(Gh)) # Convert from discrete to continuous time","category":"page"},{"location":"examples/temp/","page":"Temperature control","title":"Temperature control","text":"bp = bodeplot(G, w, lab = \"G (true)\", hz = true, l = 5)\nbodeplot!(Gh, w, lab = \"arx\", hz = true)\nbodeplot!(Gh2, w, lab = \"plr\", hz = true, ticks = :default)\n\nsp = plot(step(G, 150), lab=\"G (true)\")\nplot!(step(Gh, 150), lab = \"arx\")\nplot!(step(Gh2, 150), lab = \"plr\", ticks = :default)\nhline!([1], primary = false, l = (:black, :dash))\n\nlp = plot(lsim(ss(G), u), lab=\"G (true)\")\nplot!(lsim(ss(Gh), u), lab = \"arx\")\nplot!(lsim(ss(Gh2), u), lab = \"plr\", ticks = :default)\nplot!(data.t, yn[:], lab = \"Estimation data\")\n\nplot(bp, sp, lp, layout = @layout([[a b]; c]))","category":"page"},{"location":"ss/#LTI-state-space-models","page":"State-space estimation","title":"LTI state-space models","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"There exist several methods for identification of statespace models, subspaceid, n4sid and newpem. subspaceid is the most comprehensive algorithm for subspace-based identification whereas n4sid is an older implementation. newpem solves the prediction-error problem using an iterative optimization method (from Optim.jl). If unsure which method to use, try subspaceid first.","category":"page"},{"location":"ss/#Subspace-based-identification-using-n4sid-and-subspaceid","page":"State-space estimation","title":"Subspace-based identification using n4sid and subspaceid","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"using ControlSystemIdentification, ControlSystems\nTs = 1\nG  = ssrand(1,1,3; Ts, proper=true)\nu  = randn(1,1000)\ny  = lsim(G,u).y\nd  = iddata(y,u,Ts)\nsys = n4sid(d, :auto; verbose=false, zeroD=true)\n# or use a robust version of svd if y has outliers or missing values\n# using TotalLeastSquares\n# sys = n4sid(d, :auto; verbose=false, svd=x->rpca(x)[3])\nbodeplot([G, sys.sys])","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Estimate a statespace model using the n4sid method. Returns an object of type N4SIDResult where the model is accessed as sys.sys. The frequency-weighting functionality is borrowing ideas from \"Frequency Weighted Subspace Based System Identification in the Frequency Domain\", Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Using the function subspaceid instead, we have","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"sys2 = subspaceid(d, :auto; verbose=false, zeroD=true)\nbodeplot!(sys2.sys)","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"subspaceid allows you to choose the weighting between :MOESP, :CVA, :N4SID, :IVM and is generally preferred over n4sid.","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Both functions allow you to choose which functions are used for least-squares estimates and computing the SVD.","category":"page"},{"location":"ss/#ERA-and-OKID","page":"State-space estimation","title":"ERA and OKID","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"The \"Eigenvalue realization algorithm\" and \"Observer Kalman identification\" algorithms are available as era and okid.","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"sys3 = era(d, 3)\nbodeplot!(sys3)","category":"page"},{"location":"ss/#PEM-(Prediction-error-method)","page":"State-space estimation","title":"PEM (Prediction-error method)","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"note: Note\nThe old function pem is \"soft deprecated\" in favor of newpem which is more general and much more performant.","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"A simple algorithm for identification of discrete-time LTI systems on state-space form:","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"beginaligned\nx = Ax + Bu + Ke \ny  = Cx + Du + e\nendaligned","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"is provided. The user can choose to minimize either prediction errors or simulation errors, with arbitrary metrics, i.e., not limited to squared errors.","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"The result of the identification with newpem is a custom type with extra fields for the identified Kalman gain and noise covariance matrices.","category":"page"},{"location":"ss/#Usage-example","page":"State-space estimation","title":"Usage example","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Below, we generate a system and simulate it forward in time. We then try to estimate a model based on the input and output sequences using the function newpem.","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"using ControlSystemIdentification, ControlSystems, Random, LinearAlgebra\nusing ControlSystemIdentification: newpem\nsys = c2d(tf(1, [1, 0.5, 1]) * tf(1, [1, 1]), 0.1)\n\nRandom.seed!(1)\nT   = 1000                      # Number of time steps\nnx  = 3                         # Number of poles in the true system\nnu  = 1                         # Number of inputs\nx0  = randn(nx)                 # Initial state\nsim(sys,u,x0=x0) = lsim(ss(sys), u, x0=x0).y # Helper function\nu   = randn(nu,T)               # Generate random input\ny   = sim(sys, u, x0)           # Simulate system\nd   = iddata(y,u,0.1)\n\nsysh,opt = newpem(d, nx, focus=:prediction) # Estimate model\n\nyh = predict(sysh, d)      # Predict using estimated model\npredplot(sysh, d)   # Plot prediction and true output","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"See the example notebooks for more plots.","category":"page"},{"location":"ss/#Internals","page":"State-space estimation","title":"Internals","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Internally, Optim.jl is used to optimize the system parameters, using automatic differentiation to calculate gradients (and Hessians where applicable). Optim solver options can be controlled by passing keyword arguments to newpem, and by passing a manually constructed solver object. The default solver is BFGS()","category":"page"},{"location":"ss/#Filtering-and-simulation","page":"State-space estimation","title":"Filtering and simulation","text":"","category":"section"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Models can be simulated using lsim from ControlSystems.jl and using simulate. You may also convert the model to a KalmanFilter from LowLevelParticleFilters.jl by calling KalmanFilter(sys), after which you can perform filtering and smoothing etc. with the utilities provided for a KalmanFilter.","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"Furthermore, we have the utility functions below","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"predict(sys, d, x0=zeros): Form predictions using estimated sys, this essentially runs a stationary Kalman filter.\nsimulate(sys, u, x0=zeros): Simulate the system using input u. The noise model and Kalman gain does not have any influence on the simulated output.\nobserver_predictor: Extract the predictor model from the estimated system (ss(A-KC,[B K],C,D)).\nobserver_controller\nprediction_error\npredictiondata\nnoise_model","category":"page"},{"location":"ss/","page":"State-space estimation","title":"State-space estimation","text":"ControlSystemIdentification.subspaceid\nControlSystemIdentification.n4sid\nControlSystemIdentification.newpem\nControlSystemIdentification.era\nControlSystemIdentification.okid","category":"page"},{"location":"ss/#ControlSystemIdentification.subspaceid","page":"State-space estimation","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(\n    data::InputOutputData,\n    nx = :auto;\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used\n    s1 = r, # number of past outputs\n    s2 = r, # number of past inputs\n    W = :MOESP,\n    zeroD = false,\n    stable = true, \n    focus = :prediction,\n    svd::F1 = svd!,\n    scaleU = true,\n    Aestimator::F2 = \\,\n    Bestimator::F3 = \\,\n    weights = nothing,\n)\n\nEstimate a state-space model using subspace-based identification.\n\nRef: Ljung, Theory for the user.\n\nArguments:\n\ndata: Identification data iddata\nnx: Rank of the model (model order)\nverbose: Print stuff?\nr: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.\ns1: past horizon of outputs\ns2: past horizon of inputs\nW: Weight type, choose between :MOESP, :CVA, :N4SID, :IVM\nzeroD: Force the D matrix to be zero.\nstable: Stabilize unstable system using eigenvalue reflection.\nfocus: :prediction or simulation\nsvd: The function to use for svd\nscaleU: Rescale the input channels to have the same energy.\nAestimator: Estimator function used to estimate A,C.\nBestimator: Estimator function used to estimate B,D.\nweights: A vector of weights can be provided if the Bestimator is wls. \n\nExtended help\n\nA more accurate prediciton model can sometimes be obtained using newpem, which is also unbiased for closed-loop data (subspaceid is biased for closed-loop data, see example in the docs). The prediction-error method is iterative and generally more expensive than subspaceid, and uses this function (by default) to form the initial guess for the optimization.\n\n\n\n\n\nsubspaceid(frd::FRD, args...; estimate_x0 = false, kwargs...)\n\nIf a frequency-reponse data object is supplied\n\nThe FRD will be automatically converted to an InputOutputFreqData\nestimate_x0 is by default set to 0.\n\n\n\n\n\nsubspaceid(data::InputOutputFreqData,\n    Ts = data.Ts,\n    nx = :auto;\n    cont = false,\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order\n    zeroD = false,\n    estimate_x0 = true,\n    stable = true, \n    svd = svd!,\n    Aestimator = \\,\n    Bestimator = \\,\n    weights = nothing\n)\n\nEstimate a state-space model using subspace-based identification in the frequency domain.\n\nArguments:\n\ndata: A frequency-domain identification data object.\nTs: Sample time at which the data was collected\nnx: Desired model order, an interer or :auto.\ncont: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function d2c.\nverbose: Print stuff?\nr: Internal model order, must be ≥ nx.\nzeroD: Force the D matrix to be zero.\nestimate_x0: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.\nstable: For the model to be stable (uses schur_stab).\nsvd: The svd function to use.\nAestimator: The estimator of the A matrix (and initial C-matrix).\nBestimator: The estimator of B/D and C/D matrices.\nweights: An optional vector of frequency weights of the same length as the number of frequencies in `data.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.n4sid","page":"State-space estimation","title":"ControlSystemIdentification.n4sid","text":"res = n4sid(data, r=:auto; verbose=false)\n\nEstimate a statespace model using the n4sid method. Returns an object of type N4SIDStateSpace where the model is accessed as res.sys.\n\nImplements the simplified algorithm (alg 2) from \"N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems\" PETER VAN OVERSCHEE and BART DE MOOR\n\nThe frequency weighting is borrowing ideas from \"Frequency Weighted Subspace Based System Identification in the Frequency Domain\", Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).\n\nArguments:\n\ndata: Identification data data = iddata(y,u)\nr: Rank of the model (model order)\nverbose: Print stuff?\nWf: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like Wf = Bandstop(lower, upper, fs=1/Ts) to indicate that there are disturbances outside this band.\ni: Algorithm parameter, generally no need to tune this\nγ: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.\nzeroD: defaults to false\n\nSee also the newer implementation subspaceid which allows you to choose between different weightings (n4sid being one of them). A more accurate prediciton model can sometimes be obtained using newpem, which is also unbiased for closed-loop data.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.newpem","page":"State-space estimation","title":"ControlSystemIdentification.newpem","text":"sys, x0, res = newpem(\n    d,\n    nx;\n    zeroD  = true,\n    focus  = :prediction,\n    stable = true,\n    sys0   = subspaceid(d, nx; zeroD, focus, stable),\n    metric = abs2,\n    regularizer = (p, P) -> 0,\n    optimizer = BFGS(\n        linesearch = LineSearches.BackTracking(),\n    ),\n    store_trace = true,\n    show_trace  = true,\n    show_every  = 50,\n    iterations  = 10000,\n    time_limit  = 100,\n    x_tol       = 0,\n    f_abstol    = 0,\n    g_tol       = 1e-12,\n    f_calls_limit = 0,\n    g_calls_limit = 0,\n    allow_f_increases = false,\n)\n\nA new implementation of the prediction-error method (PEM). Note that this is an experimental implementation and subject to breaking changes not respecting semver.\n\nThe prediction-error method is an iterative, gradient-based optimization problem, as such, it can be extra sensitive to signal scaling, and it's recommended to perform scaling to d before estimation, e.g., by pre and post-multiplying with diagonal matrices d̃ = Dy*d*Du, and apply the inverse scaling to the resulting system. In this case, we have\n\nD_y y = G D_u u  y = D_y^-1 G D_u u\n\nhence G = Dy \\ G̃ * Du where $ G̃ $ is the plant estimated for the scaled iddata.\n\nArguments:\n\nd: iddata\nnx: Model order\nzeroD: Force zero D matrix\nstable if true, stability of the estimated system will be enforced by eigenvalue reflection using schur_stab with ϵ=Ts/100 (default). If stable is a real value, the value is used instead of the default ϵ.\nsys0: Initial guess, if non provided, subspaceid is used as initial guess.\nfocus: prediction or :simulation. If :simulation, hte K matrix will be zero.\noptimizer: One of Optim's optimizers\nmetric: The metric used to measure residuals. Try, e.g., abs for better resistance to outliers.\n\nThe rest of the arguments are related to Optim.Options.\n\nregularizer: A function of the parameter vector and the corresponding PredictionStateSpace/StateSpace system that can be used to regularize the estimate.\n\nExample\n\nusing ControlSystemIdentification, ControlSystems, Plots\nG = DemoSystems.doylesat()\nT = 1000  # Number of time steps\nTs = 0.01 # Sample time\nsys = c2d(G, Ts)\nnx = sys.nx\nnu = sys.nu\nny = sys.ny\nx0 = zeros(nx) # actual initial state\nsim(sys, u, x0 = x0) = lsim(sys, u; x0)[1]\n\nσy = 1e-1 # Noise covariance\n\nu  = randn(nu, T)\ny  = sim(sys, u, x0)\nyn = y .+ σy .* randn.() # Add measurement noise\nd  = iddata(yn, u, Ts)\n\nsysh, x0h, opt = ControlSystemIdentification.newpem(d, nx, show_every=10)\n\nplot(\n    bodeplot([sys, sysh]),\n    predplot(sysh, d, x0h), # Include the estimated initial state in the prediction\n)\n\nExtended help\n\nThis implementation uses a tridiagonal parametrization of the A-matrix that has been shown to be favourable from an optimization perspective.¹ The initial guess sys0 is automatically transformed to a special tridiagonal modal form.  [1]: Mckelvey, Tomas & Helmersson, Anders. (1997). State-space parametrizations of multivariable linear systems using tridiagonal matrix forms.\n\nThe parameter vector used in the optimizaiton takes the following form\n\np = [trivec(A); vec(B); vec(C); vec(D); vec(K); vec(x0)]\n\nWhere ControlSystemIdentification.trivec vectorizes the -1,0,1 diagonals of A. If focus = :simulation, K is omitted, and if zeroD = true, D is omitted.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.era","page":"State-space estimation","title":"ControlSystemIdentification.era","text":"era(YY::AbstractArray{<:Any, 3}, Ts, r::Int, m::Int, n::Int)\n\nEigenvalue realization algorithm.\n\nArguments:\n\nYY: Markov parameters (impulse response) size n_out×n_in×n_time\nTs: Sample time\nr: Model order\nm: Number of rows in Hankel matrix\nn: Number of columns in Hankel matrix\n\n\n\n\n\nera(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r; p = l, λ=0)\n\nEigenvalue realization algorithm. Uses okid to find the Markov parameters as an initial step.\n\nArguments:\n\nr: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, for era, p defaults to l, while when calling okid directly, p defaults to 0.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.okid","page":"State-space estimation","title":"ControlSystemIdentification.okid","text":"H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)\n\nObserver Kalman filter identification. Returns the Markov parameters H size n_out×n_in×l+1\n\nArguments:\n\nnx: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, try setting p around the same value as l.\n\n\n\n\n\n","category":"function"},{"location":"validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"A number of functions are made available to assist in validation of the estimated models. We illustrate by an example","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"Generate some test data:","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"using ControlSystemIdentification, ControlSystems, Random\nusing ControlSystemIdentification: newpem\nRandom.seed!(1)\nT          = 200\nnx         = 2\nnu         = 1\nny         = 1\nx0         = randn(nx)\nσy         = 0.5\nsim(sys,u) = lsim(sys, u, 1:T)[1]\nsys        = tf(1, [1, 2*0.1, 0.1])\nsysn       = tf(σy, [1, 2*0.1, 0.3])\n# Training data\nu          = randn(nu,T)\ny          = sim(sys, u)\nyn         = y + sim(sysn, randn(size(u)))\ndn         = iddata(yn, u, 1)\n# Validation data\nuv         = randn(nu, T)\nyv         = sim(sys, uv)\nynv        = yv + sim(sysn, randn(size(uv)))\ndv         = iddata(yv, uv, 1)\ndnv        = iddata(ynv, uv, 1)","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"We then fit a couple of models","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"res = [newpem(dn, nx, focus=:prediction) for nx = [2,3,4]];\nnothing # hide","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"After fitting the models, we validate the results using the validation data and the functions simplot and predplot (cf. Matlab sys.id's compare):","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"using Plots\nω   = exp10.(range(-2, stop=log10(pi), length=150))\nfig = plot(layout=4, size=(1000,600))\nfor i in eachindex(res)\n    sysh, x0h, opt = res[i]\n    simplot!( sysh, dnv, x0h; sp=1, ploty=false)\n    predplot!(sysh, dnv, x0h; sp=2, ploty=false)\nend\nplot!(dnv.y' .* [1 1], lab=\"y\", l=(:dash, :black), sp=[1 2])\nbodeplot!((getindex.(res,1)),                     ω, plotphase=false, subplot=3, title=\"Process\", linewidth=2*[4 3 2 1])\nbodeplot!(innovation_form.(getindex.(res,1)),     ω, plotphase=false, subplot=4, linewidth=2*[4 3 2 1])\nbodeplot!(sys,                                    ω, plotphase=false, subplot=3, lab=\"True\", l=(:black, :dash), legend = :bottomleft, title=\"System model\")\nbodeplot!(innovation_form(ss(sys),syse=ss(sysn)), ω, plotphase=false, subplot=4, lab=\"True\", l=(:black, :dash), ylims=(0.1, 100), legend = :bottomleft, title=\"Noise model\")","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"In the figure, simulation output is compared to the true model on the top left and prediction on top right. The system models and noise models are visualized in the bottom plots. All models capture the system dynamics reasonably well, but struggle slightly with capturing the gain of the noise dynamics. The true system has 4 poles (two in the process and two in the noise process) but a simpler model may sometimes work better.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"Prediction models may also be evaluated using a h-step prediction, here h is short for \"horizon\".","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"figh = plot()\nfor i in eachindex(res)\n    sysh, x0h, opt = res[i]\n    predplot!(sysh, dnv, x0h, ploty=false, h=5)\nend\nplot!(dnv.y', lab=\"y\", l=(:dash, :black))\nfigh","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"It's generally a good idea to validate estimated model with a prediction horizon larger than one, in particular, it may be valuable to verify the performance for a prediction horizon that corresponds roughly to the dominant time constant of the process.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"See also simulate, predplot, simplot, coherenceplot","category":"page"},{"location":"validation/#Different-length-predictors","page":"Validation","title":"Different length predictors","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"When the prediction horizon gets longer, the mapping from u rightarrow y approaches that of the simulation system, while the mapping y rightarrow y gets smaller and smaller.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"using LinearAlgebra\nG   = c2d(DemoSystems.resonant(), 0.1)\nK   = kalman(G, I(G.nx), I(G.ny))\nsys = add_input(G, K, I(G.ny)) # Form an innovation model with inputs u and e\n\nT = 10000\nu = randn(G.nu, T)\ne = 0.1randn(G.ny, T)\ny = lsim(sys, [u; e]).y\nd = iddata(y, u, G.Ts)\nGh,_ = newpem(d, G.nx, zeroD=true)\n\n# Create predictors with different horizons\np1   = observer_predictor(Gh)\np2   = observer_predictor(Gh, h=2)\np10  = observer_predictor(Gh, h=10)\np100 = observer_predictor(Gh, h=100)\n\nbodeplot([p1, p2, p10, p100], plotphase=false, lab=[\"1\" \"\" \"2\" \"\" \"10\" \"\" \"100\" \"\"])\nbodeplot!(sys, ticks=:default, plotphase=false, l=(:black, :dash), lab=[\"sim\" \"\"], title=[\"From u\" \"From y\"])","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"The prediction error as a function of prediction horizon approaches the simulation error.","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"using Statistics\nhs = [1:40; 45:5:80]\nperrs = map(hs) do h\n    yh = predict(Gh, d; h)\n    ControlSystemIdentification.rms(d.y - yh) |> mean\nend\nserr = ControlSystemIdentification.rms(d.y - simulate(Gh, d)) |> mean\n\nplot(hs, perrs, lab=\"Prediction errors\", xlabel=\"Horizon\", ylabel=\"RMS error\")\nhline!([serr], lab=\"Simulation error\", l=:dash, legend=:bottomright, ylims=(0, Inf))","category":"page"},{"location":"impulse/#Impulse-response-estimation","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"","category":"section"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"The functions impulseest(h,y,u,order) and impulseestplot perform impulse-response estimation by fitting a high-order FIR model. The function okid estimates Markov parameters and is applicable to MIMO systems.","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"SISO example","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"T = 200\nh = 1\nt = 0:h:T-h\nsys = c2d(tf(1,[1,2*0.1,0.1]),h)\n\nu  = randn(1, length(t))\nres = lsim(sys, u, t)\nd  = iddata(res)\n\nimpulseestplot(d,50, lab=\"Estimate\", seriestype=:steppost)\nplot!(impulse(sys,50), lab=\"True system\", l=:dash)","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"(Image: window)","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"MIMO example","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"using ControlSystemIdentification, ControlSystems, Plots\nT = 200\nh = 1\nt = 0:h:T-h\nsys = ssrand(2,2,4, proper=true, Ts=h)\n\nu  = randn(sys.nu, length(t))\nres = lsim(sys, u, t)\nd  = iddata(res)\n\nH = okid(d, sys.nx)\nplot(impulse(sys,50), lab=\"True system\", layout=sys.ny+sys.nu, sp=(1:4)')\nplot!(reshape(H, sys.nu+sys.ny, :)', lab=\"OKID Estiamte\", seriestype=:steppre, l=:dash)","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"See the example notebooks for more details.","category":"page"},{"location":"impulse/","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"ControlSystemIdentification.impulseest\nControlSystemIdentification.impulseestplot","category":"page"},{"location":"impulse/#ControlSystemIdentification.impulseest","page":"Impulse-response estimation","title":"ControlSystemIdentification.impulseest","text":"ir, t, Σ = impulseest(d::AbstractIdData, n; λ=0, estimator=ls)\n\nEstimates the system impulse response by fitting an n:th order FIR model. Returns impulse-response estimate, time vector and covariance matrix. See also impulseestplot\n\n\n\n\n\n","category":"function"},{"location":"examples/closed_loop_id/#Closed-loop-identification","page":"Identification in closed loop","title":"Closed-loop identification","text":"","category":"section"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"This example will investigate how different identification algorithms perform on closed-loop data, i.e., when the input to the system is produced by a controller using output feedback.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"We will consider a very simple system G(z) = dfrac1z - 09 with colored output noise and various inputs formed by state feedback u = -Lx + r(t), where r will vary between the experiments.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"It is well known that in the absence of r and with a simple regulator, identifiability is poor, indeed, if","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"y_k+1 = a y_k + b u_k quad u_k = L*y_k","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"we get the closed-loop system","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"y_k+1 = (a + bL)y_k","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"where we can not distinguish a and b. The introduction of r resolves this","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"beginaligned\ny_k+1 = a y_k + b u_k \nu_k = L*y_k + r \ny_k+1 = (a + bL)y_k + b r_k\nendaligned","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"The very first experiment below will illustrate the problem when there is no excitation through r.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"We start by defining a model of the true system, a function that simulates some data and adds colored output noise, as well as a function that estimates three different models and plots their frequency responses. We will consider three estimation methods","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"arx, a prediction-error approach based on a least-squares estimate.\nA subspace-based method subspaceid, known to be biased in the presence of output feedback.\nThe prediction-error method (PEM) newpem","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"The ARX and PEM methods are theoretically unbiased in the presence of output feedback, see [^Ljung, Ch 13], while the subspace-based method is not. (Note: the subspace-based method is used to form the initial guess for the iterative PEM algorithm)","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"using ControlSystems, ControlSystemIdentification, Plots\nG = tf(1, [1, -0.9], 1) # True system\n\nfunction generate_data(u; T)\n    res = lsim(G, u, 1:T, x0 = [1])\n    d = iddata(res)\n    E = c2d(tf(1 / 100, [1, 0.01, 0.1]), 1)\n    e = lsim(E, randn(1, T)).y\n    d.y .+= e\n    d\nend\n\nfunction estimate_and_plot(d, nx=1; title)\n    Gh1 = arx(d, 1, 1)\n\n    sys0 = subspaceid(d, nx)\n    tf(sys0)\n\n    Gh2, _ = ControlSystemIdentification.newpem(d, nx; sys0)\n    tf(Gh2)\n\n    bodeplot(\n        [G, Gh1, sys0.sys, Gh2.sys];\n        ticks = :default,\n        title,\n        lab = [\"True system\" \"ARX\" \"Subspace\" \"PEM\"],\n        plotphase = false,\n    )\nend","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"In the first experiment, we have no reference excitation, with a small amount of data (T=80), we get terrible estimates","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"L = 0.5 # Feedback gain u = -L*x\nu = (x, t) -> -L * x\ntitle = \"-Lx\"\nestimate_and_plot(generate_data(u, T=80), title=title*\",  T=80\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"with a larger amount of data T=8000, we get equally terrible estimates","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"estimate_and_plot(generate_data(u, T=8000), title=title*\",  T=8000\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"This indicates that we can not hope to estimate a model if the system is driven by noise only.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"We now consider a simple, periodic excitation r = sin(t)","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"L = 0.5 # Feedback gain u = -L*x\nu = (x, t) -> -L * x .+ 5sin(t)\ntitle = \"-Lx + 5sin(t)\"\nestimate_and_plot(generate_data(u, T=80), title=title*\",  T=80\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"In this case, all but the subspace-based method performs quite well","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"estimate_and_plot(generate_data(u, T=8000), title=title*\",  T=8000\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"More data does not help the subspace method.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"With a more complex excitation (random white-spectrum noise), all methods perform well","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"L = 0.5 # Feedback gain u = -L*x\nu = (x, t) -> -L * x .+ 5randn()\ntitle = \"-Lx + 5randn()\"\nestimate_and_plot(generate_data(u, T=80), title=title*\",  T=80\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"and even slightly better with more data.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"estimate_and_plot(generate_data(u, T=8000), title=title*\",  T=8000\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"If the feedback is strong but the excitation is weak, the results are rather poor for all methods, it's thus important to have enough energy in the excitation compared to the feedback path.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"L = 1 # Feedback gain u = -L*x\nu = (x, t) -> -L * x .+ 0.1randn()\ntitle = \"-Lx + 0.1randn()\"\nestimate_and_plot(generate_data(u, T=80), title=title*\",  T=80\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"In this case, we can try to increase the model order of the PEM and subspace-based methods to see if they are able to learn the noise model (which has two poles)","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"estimate_and_plot(generate_data(u, T=8000), 3, title=title*\",  T=8000\")","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"learning the noise model can sometimes work reasonably well, but requires more data. You may extract the learned noise model using noise_model.","category":"page"},{"location":"examples/closed_loop_id/","page":"Identification in closed loop","title":"Identification in closed loop","text":"[^Ljung, Ch 13]: Ljung, Lennart. \"System identification–-Theory for the user\".","category":"page"},{"location":"freq/#Transfer-function-estimation-using-spectral-techniques","page":"Frequency-domain estimation","title":"Transfer-function estimation using spectral techniques","text":"","category":"section"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"Frequency-domain estimation refers to estimation of linear systems using frequency-domain data. We distinguish between nonparametric and parametric models, where parametric models have a fixed number of parameters (such as transfer functions with polynomials or statespace models), whereas nonparametric models are typically given as vectors of frequency-response values over a grid of frequencies, i.e., the number of parameters is not fixed and grows with the number of data points.","category":"page"},{"location":"freq/#Nonparametric-estimation","page":"Frequency-domain estimation","title":"Nonparametric estimation","text":"","category":"section"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"Non-parametric estimation is provided through spectral estimation. To illustrate, we once again simulate some data:","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"T          = 100000\nh          = 1\nsim(sys,u) = lsim(sys, u, 1:T)[1][:]\nσy         = 0.5\nsys        = tf(1,[1,2*0.1,0.1])\nωn         = sqrt(0.3)\nsysn       = tf(σy*ωn,[1,2*0.1*ωn,ωn^2])\n\nu  = randn(T)\ny  = sim(sys, u)\nyn = y + sim(sysn, randn(size(u)))\nd  = iddata(y,u,h)\ndn = iddata(yn,u,h)","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"We can now estimate the coherence function to get a feel for whether or nor our data seems to be generated by a linear system:","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"k = coherence(d)  # Should be close to 1 if the system is linear and noise free\nk = coherence(dn) # Slightly lower values are obtained if the system is subject to measurement noise","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"We can also estimate a transfer function using spectral techniques, the main entry point to this is the function tfest, which returns a transfer-function estimate and an estimate of the power-spectral density of the noise (note, the unit of the PSD is squared compared to a transfer function, hence the √N when plotting it in the code below):","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"G,N = tfest(dn)\nbodeplot([sys,sysn], exp10.(range(-3, stop=log10(pi), length=200)), layout=(1,3), plotphase=false, subplot=[1,2,2], size=(3*800, 600), ylims=(0.1,300), linecolor=:blue)\n\ncoherenceplot!(dn, subplot=3)\nplot!(G, subplot=1, lab=\"G Est\", alpha=0.3, title=\"Process model\")\nplot!(√N, subplot=2, lab=\"N Est\", alpha=0.3, title=\"Noise model\")","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"(Image: window)","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"The left figure displays the Bode magnitude of the true system, together with the estimate (noisy), and the middle figure illustrates the estimated noise model. The right figure displays the coherence function (coherenceplot), which is close to 1 everywhere except for at the resonance peak of the noise log10(sqrt(0.3)) = -0.26.","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"See the example notebooks for more details.","category":"page"},{"location":"freq/#Parametric-estimation","page":"Frequency-domain estimation","title":"Parametric estimation","text":"","category":"section"},{"location":"freq/#Transfer-functions","page":"Frequency-domain estimation","title":"Transfer functions","text":"","category":"section"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"To estimate a parametric, rational transfer function from frequency-domain data, call tfest with an FRD object and an initial guess for the system model. This initial guess determines the number of coefficients in the numerator and denominator of the estimated model.","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"G0 = tf(1.0, [1,1,1]) # Initial guess\nG = tfest(d::FRD, G0)","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"Internally, Optim is using a gradient-based optimizer to find the optimal fit of the bode curve of the system. The default optimizer BFGS can be changed, see the docstring ?tfest.","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"For a comparison between estimation in the time and frequency domains, see this notebook.","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"If the above problem is hard to solve, you may parametrize the model using, e.g., a Laguerre basis expansion, example:","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"basis = laguerre_oo(1, 50) # Use 50 basis functions, the final model order may be reduced with baltrunc\nGest,p = tfest(d::FRD, basis)","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"note: Note\nMost methods for frequency-domain estimation of transfer functions handle SISO or SIMO systems only. For estimation of MIMO systems, consider using state-space based methods and convert the result to a transfer function using tf after estimation if required. ","category":"page"},{"location":"freq/#Statespace","page":"Frequency-domain estimation","title":"Statespace","text":"","category":"section"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"The function subspaceid handles frequency-domain data (as well as time-domain data). If an InputOutputFreqData is passed (may be created with function iddata), a frequency-domain method is automatically used. Further, a frequency-response object, FRD, may also be passed, in which case it is transformed to an InputOutputFreqData automatically. If the frequency-response data stems from a frequency-response analysis, you may need to perform a bilinear transform on the frequency axis of the data object to convert the continuous-time frequency axis to discrete time, example:","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"Ts    = 0.01 # Sample time\nfrd_d = c2d(frd_c::FRD, Ts) # Perform a bilinear transformation to discrete-time frequency vector\nPh, _ = subspaceid(frd_d, Ts, nx)","category":"page"},{"location":"freq/#Model-based-spectral-estimation","page":"Frequency-domain estimation","title":"Model-based spectral estimation","text":"","category":"section"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"The model estimation procedures can be used to estimate spectrograms. This package extends some methods from DSP.jl to accept a estimation function as the second argument. To create a suitable such function, we provide the function model_spectrum. Usage is illustrated below.","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"using ControlSystemIdentification, DSP\nT  = 1000\nfs = 1\ns = sin.((1:1/fs:T) .* 2pi/10) + 0.5randn(T)\nS1 = spectrogram(s,window=hanning, fs=fs)            # Standard spectrogram\nestimator = model_spectrum(ar,1/fs,6)\nS2 = spectrogram(s,estimator,window=rect, fs=fs)     # Model-based spectrogram\nplot(plot(S1,title=\"Standard Spectrogram\"),plot(S2,title=\"AR Spectrogram\")) # Requires the package LPVSpectral.jl","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"(Image: window)","category":"page"},{"location":"freq/","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"ControlSystemIdentification.tfest\nControlSystemIdentification.coherence\nControlSystemIdentification.laguerre_oo\nControlSystemIdentification.model_spectrum","category":"page"},{"location":"freq/#ControlSystemIdentification.tfest","page":"Frequency-domain estimation","title":"ControlSystemIdentification.tfest","text":"H, N = tfest(data, σ = 0.05)\n\nEstimate a transfer function model using the Correlogram approach. Both H and N are of type FRD (frequency-response data).\n\nσ determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger σ implies less smoothing.\nH = Syu/Suu             Process transfer function\nN = Sy - |Syu|²/Suu     Noise PSD\n\n\n\n\n\ntfest(\n    data::FRD,\n    p0,\n    link = log ∘ abs;\n    freq_weight = sqrt(data.w[1]*data.w[end]),\n    refine = true,\n    opt = BFGS(),\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 1,\n        iterations        = 100,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 0,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n    ),\n)\n\nFit a parametric transfer function to frequency-domain data.\n\nThe initial pahse of the optimization solves\n\noperatornameminimize_BA Bl - A\n\nand the second stage (if refine=true) solves \n\noperatornameminimize_BA textlinkleft(dfracBAright) - textlinkleft(lright)\n\n(abs2(link(B/A) - link(l)))\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\np0: Initial parameter guess. Can be a NamedTuple or ComponentVector with fields b,a specifying numerator and denominator as they appear in the call to tf, i.e., (b = [1.0], a = [1.0,1.0,1.0]). Can also be an instace of TransferFunction.\nlink: By default, phase information is discarded in the fitting. To include phase, change to link = log.\nfreq_weight: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.\nrefine: Indicate whether or not a second optimization stage is performed to refine the results of the first.\nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\nSee also minimum_phase to transform a possibly non-minimum phase system to minimum phase.\n\n\n\n\n\ntfest(data::FRD, basis::AbstractStateSpace; \n    freq_weight = 1 ./ (data.w .+ data.w[2]),\n    opt = BFGS(),\n    metric::M = abs2,\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 50,\n        iterations        = 1000000,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 1e-5,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n)\n\nFit a parametric transfer function to frequency-domain data using a pre-specified basis.\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\n\nfunction kautz(a::AbstractVector)\n\nbasis: A basis for the estimation. See, e.g., laguerre, laguerre_oo, kautz\nfreq_weight: A vector of weights per frequency. The default is approximately 1/f. \nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\n\n\n\n\n","category":"function"},{"location":"freq/#ControlSystemIdentification.coherence","page":"Frequency-domain estimation","title":"ControlSystemIdentification.coherence","text":"κ = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming)\n\nCalculates the magnitude-squared coherence Function. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ << 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy. κ: Coherence function (not squared) N: Noise model\n\n\n\n\n\n","category":"function"},{"location":"freq/#ControlSystemIdentification.laguerre_oo","page":"Frequency-domain estimation","title":"ControlSystemIdentification.laguerre_oo","text":"laguerre_oo(a::Number, Nq)\n\nConstruct an output orthogonalized Laguerre basis of length Nq with poles at a.\n\n\n\n\n\n","category":"function"},{"location":"freq/#ControlSystemIdentification.model_spectrum","page":"Frequency-domain estimation","title":"ControlSystemIdentification.model_spectrum","text":"model_spectrum(f, h, args...; kwargs...)\n\nArguments:\n\nf: the model-estimation function, e.g., ar,arma\nh: The sample time\nargs: arguments to f\nkwargs: keyword arguments to f\n\nExample:\n\nusing ControlSystemIdentification, DSP\nT = 1000\ns = sin.((1:T) .* 2pi/10)\nS1 = spectrogram(s,window=hanning)\nestimator = model_spectrum(ar,1,2)\nS2 = spectrogram(s,estimator,window=rect)\nplot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl\n\n\n\n\n\n","category":"function"},{"location":"#ControlSystemIdentification","page":"Home","title":"ControlSystemIdentification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"System identification for ControlSystems.jl. Examples in the form of jupyter notebooks are provided here.","category":"page"},{"location":"#Other-resources","page":"Home","title":"Other resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For estimation of linear time-varying models (LTV), see LTVModels.jl.\nFor estimation of linear and nonlinear grey-box models in continuous time, see DifferentialEquations.jl (parameter estimation)\nEstimation of nonlinear black-box models in continuous time DiffEqFlux.jl and in discrete time Flux.jl\nFor more advanced spectral estimation, cross coherence, etc., see LPVSpectral.jl\nThis package interacts well with MonteCarloMeasurements.jl. See example file.\nState estimation is facilitated by LowLevelParticleFilters.jl.","category":"page"},{"location":"iddata/#Identification-data","page":"Identification data","title":"Identification data","text":"","category":"section"},{"location":"iddata/","page":"Identification data","title":"Identification data","text":"All estimation methods in this package expect an object of type AbstractIdData, created using the function iddata. This object typically holds input and output data as well as the sample time. ","category":"page"},{"location":"iddata/","page":"Identification data","title":"Identification data","text":"ControlSystemIdentification.iddata\nControlSystemIdentification.predictiondata","category":"page"},{"location":"iddata/#ControlSystemIdentification.iddata","page":"Identification data","title":"ControlSystemIdentification.iddata","text":"iddata(y::AbstractArray, u::AbstractArray, w::AbstractVector)\n\nCreate a frequency-domain input-output data object. w is expected to be in rad/s.\n\n\n\n\n\niddata(y,       Ts = nothing)\niddata(y, u,    Ts = nothing)\niddata(y, u, x, Ts = nothing)\n\nReturns the appropriate identification-data object, depending on the input.\n\nArguments\n\ny::AbstractArray: output data (required)\nu::AbstractArray: input data (if available)\nx::AbstractArray: state data (if available)\nTs::Union{Real,Nothing} = nothing: optional sample time\n\nIf the time-series are multivariate, time is in the last dimension.\n\nOperations on iddata\n\nprefilter\nresample\nappend two along the time dimension [d1 d2]\nindex time series d[output_index, input_index]\nindex the time axis with indices d[time_indices]\nindex the time axis with seconds d[3Sec:12Sec] (using ControlSystemIdentification: Sec)\naccess number of inputs, outputs and sample time: d.nu, d.ny, d.Ts\naccess the time time vector d.t\npremultiply to scale outputs C * d\npostmultiply to scale inputs d * B\nwritedlm\nramp_in, ramp_out\nplot\nspecplot\n\nExamples\n\njulia> iddata(randn(10))\nOutput data of length 10 with 1 outputs\n\njulia> iddata(randn(10), randn(10), 1)\nInputOutput data of length 10 with 1 outputs and 1 inputs\n\njulia> d = iddata(randn(2, 10), randn(3, 10), 0.1)\nInputOutput data of length 10 with 2 outputs and 3 inputs\n\njulia> [d d] # Concatenate along time\nInputOutput data of length 20 with 2 outputs and 3 inputs\n\njulia> d[1:3]\nInputOutput data of length 3 with 2 outputs and 3 inputs\n\njulia> d.nu\n3\n\njulia> d.t # access time vector\n0.0:0.1:0.9\n\n\n\n\n\n","category":"function"},{"location":"iddata/#ControlSystemIdentification.predictiondata","page":"Identification data","title":"ControlSystemIdentification.predictiondata","text":"predictiondata(d::AbstractIdData)\n\nAdd the output y to the input u_new = [u; y]\n\n\n\n\n\n","category":"function"},{"location":"iddata/","page":"Identification data","title":"Identification data","text":"Some frequency-domain methods accept or return objects of type FRD, representing frequency-response data.","category":"page"}]
}
